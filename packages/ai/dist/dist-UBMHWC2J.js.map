{"version":3,"sources":["../../../node_modules/.pnpm/@ai-sdk+mistral@3.0.2_zod@4.2.1/node_modules/@ai-sdk/mistral/src/mistral-provider.ts","../../../node_modules/.pnpm/@ai-sdk+mistral@3.0.2_zod@4.2.1/node_modules/@ai-sdk/mistral/src/mistral-chat-language-model.ts","../../../node_modules/.pnpm/@ai-sdk+mistral@3.0.2_zod@4.2.1/node_modules/@ai-sdk/mistral/src/convert-mistral-usage.ts","../../../node_modules/.pnpm/@ai-sdk+mistral@3.0.2_zod@4.2.1/node_modules/@ai-sdk/mistral/src/convert-to-mistral-chat-messages.ts","../../../node_modules/.pnpm/@ai-sdk+mistral@3.0.2_zod@4.2.1/node_modules/@ai-sdk/mistral/src/get-response-metadata.ts","../../../node_modules/.pnpm/@ai-sdk+mistral@3.0.2_zod@4.2.1/node_modules/@ai-sdk/mistral/src/map-mistral-finish-reason.ts","../../../node_modules/.pnpm/@ai-sdk+mistral@3.0.2_zod@4.2.1/node_modules/@ai-sdk/mistral/src/mistral-chat-options.ts","../../../node_modules/.pnpm/@ai-sdk+mistral@3.0.2_zod@4.2.1/node_modules/@ai-sdk/mistral/src/mistral-error.ts","../../../node_modules/.pnpm/@ai-sdk+mistral@3.0.2_zod@4.2.1/node_modules/@ai-sdk/mistral/src/mistral-prepare-tools.ts","../../../node_modules/.pnpm/@ai-sdk+mistral@3.0.2_zod@4.2.1/node_modules/@ai-sdk/mistral/src/mistral-embedding-model.ts","../../../node_modules/.pnpm/@ai-sdk+mistral@3.0.2_zod@4.2.1/node_modules/@ai-sdk/mistral/src/version.ts"],"sourcesContent":["import {\n  EmbeddingModelV3,\n  LanguageModelV3,\n  NoSuchModelError,\n  ProviderV3,\n} from '@ai-sdk/provider';\nimport {\n  FetchFunction,\n  loadApiKey,\n  withoutTrailingSlash,\n  withUserAgentSuffix,\n} from '@ai-sdk/provider-utils';\nimport { MistralChatLanguageModel } from './mistral-chat-language-model';\nimport { MistralChatModelId } from './mistral-chat-options';\nimport { MistralEmbeddingModel } from './mistral-embedding-model';\nimport { MistralEmbeddingModelId } from './mistral-embedding-options';\nimport { VERSION } from './version';\n\nexport interface MistralProvider extends ProviderV3 {\n  (modelId: MistralChatModelId): LanguageModelV3;\n\n  /**\nCreates a model for text generation.\n*/\n  languageModel(modelId: MistralChatModelId): LanguageModelV3;\n\n  /**\nCreates a model for text generation.\n*/\n  chat(modelId: MistralChatModelId): LanguageModelV3;\n\n  /**\n   * Creates a model for text embeddings.\n   */\n  embedding(modelId: MistralEmbeddingModelId): EmbeddingModelV3;\n\n  /**\n   * Creates a model for text embeddings.\n   */\n  embeddingModel: (modelId: MistralEmbeddingModelId) => EmbeddingModelV3;\n\n  /**\n   * @deprecated Use `embedding` instead.\n   */\n  textEmbedding(modelId: MistralEmbeddingModelId): EmbeddingModelV3;\n\n  /**\n   * @deprecated Use `embeddingModel` instead.\n   */\n  textEmbeddingModel(modelId: MistralEmbeddingModelId): EmbeddingModelV3;\n}\n\nexport interface MistralProviderSettings {\n  /**\nUse a different URL prefix for API calls, e.g. to use proxy servers.\nThe default prefix is `https://api.mistral.ai/v1`.\n   */\n  baseURL?: string;\n\n  /**\nAPI key that is being send using the `Authorization` header.\nIt defaults to the `MISTRAL_API_KEY` environment variable.\n   */\n  apiKey?: string;\n\n  /**\nCustom headers to include in the requests.\n     */\n  headers?: Record<string, string>;\n\n  /**\nCustom fetch implementation. You can use it as a middleware to intercept requests,\nor to provide a custom fetch implementation for e.g. testing.\n    */\n  fetch?: FetchFunction;\n\n  generateId?: () => string;\n}\n\n/**\nCreate a Mistral AI provider instance.\n */\nexport function createMistral(\n  options: MistralProviderSettings = {},\n): MistralProvider {\n  const baseURL =\n    withoutTrailingSlash(options.baseURL) ?? 'https://api.mistral.ai/v1';\n\n  const getHeaders = () =>\n    withUserAgentSuffix(\n      {\n        Authorization: `Bearer ${loadApiKey({\n          apiKey: options.apiKey,\n          environmentVariableName: 'MISTRAL_API_KEY',\n          description: 'Mistral',\n        })}`,\n        ...options.headers,\n      },\n      `ai-sdk/mistral/${VERSION}`,\n    );\n\n  const createChatModel = (modelId: MistralChatModelId) =>\n    new MistralChatLanguageModel(modelId, {\n      provider: 'mistral.chat',\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n      generateId: options.generateId,\n    });\n\n  const createEmbeddingModel = (modelId: MistralEmbeddingModelId) =>\n    new MistralEmbeddingModel(modelId, {\n      provider: 'mistral.embedding',\n      baseURL,\n      headers: getHeaders,\n      fetch: options.fetch,\n    });\n\n  const provider = function (modelId: MistralChatModelId) {\n    if (new.target) {\n      throw new Error(\n        'The Mistral model function cannot be called with the new keyword.',\n      );\n    }\n\n    return createChatModel(modelId);\n  };\n\n  provider.specificationVersion = 'v3' as const;\n  provider.languageModel = createChatModel;\n  provider.chat = createChatModel;\n  provider.embedding = createEmbeddingModel;\n  provider.embeddingModel = createEmbeddingModel;\n  provider.textEmbedding = createEmbeddingModel;\n  provider.textEmbeddingModel = createEmbeddingModel;\n\n  provider.imageModel = (modelId: string) => {\n    throw new NoSuchModelError({ modelId, modelType: 'imageModel' });\n  };\n\n  return provider;\n}\n\n/**\nDefault Mistral provider instance.\n */\nexport const mistral = createMistral();\n","import {\n  LanguageModelV3,\n  LanguageModelV3CallOptions,\n  LanguageModelV3Content,\n  LanguageModelV3FinishReason,\n  LanguageModelV3GenerateResult,\n  LanguageModelV3StreamPart,\n  LanguageModelV3StreamResult,\n  SharedV3Warning,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createEventSourceResponseHandler,\n  createJsonResponseHandler,\n  FetchFunction,\n  generateId,\n  injectJsonInstructionIntoMessages,\n  parseProviderOptions,\n  ParseResult,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { convertMistralUsage, MistralUsage } from './convert-mistral-usage';\nimport { convertToMistralChatMessages } from './convert-to-mistral-chat-messages';\nimport { getResponseMetadata } from './get-response-metadata';\nimport { mapMistralFinishReason } from './map-mistral-finish-reason';\nimport {\n  MistralChatModelId,\n  mistralLanguageModelOptions,\n} from './mistral-chat-options';\nimport { mistralFailedResponseHandler } from './mistral-error';\nimport { prepareTools } from './mistral-prepare-tools';\n\ntype MistralChatConfig = {\n  provider: string;\n  baseURL: string;\n  headers: () => Record<string, string | undefined>;\n  fetch?: FetchFunction;\n  generateId?: () => string;\n};\n\nexport class MistralChatLanguageModel implements LanguageModelV3 {\n  readonly specificationVersion = 'v3';\n\n  readonly modelId: MistralChatModelId;\n\n  private readonly config: MistralChatConfig;\n  private readonly generateId: () => string;\n\n  constructor(modelId: MistralChatModelId, config: MistralChatConfig) {\n    this.modelId = modelId;\n    this.config = config;\n    this.generateId = config.generateId ?? generateId;\n  }\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  readonly supportedUrls: Record<string, RegExp[]> = {\n    'application/pdf': [/^https:\\/\\/.*$/],\n  };\n\n  private async getArgs({\n    prompt,\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    frequencyPenalty,\n    presencePenalty,\n    stopSequences,\n    responseFormat,\n    seed,\n    providerOptions,\n    tools,\n    toolChoice,\n  }: LanguageModelV3CallOptions) {\n    const warnings: SharedV3Warning[] = [];\n\n    const options =\n      (await parseProviderOptions({\n        provider: 'mistral',\n        providerOptions,\n        schema: mistralLanguageModelOptions,\n      })) ?? {};\n\n    if (topK != null) {\n      warnings.push({ type: 'unsupported', feature: 'topK' });\n    }\n\n    if (frequencyPenalty != null) {\n      warnings.push({ type: 'unsupported', feature: 'frequencyPenalty' });\n    }\n\n    if (presencePenalty != null) {\n      warnings.push({ type: 'unsupported', feature: 'presencePenalty' });\n    }\n\n    if (stopSequences != null) {\n      warnings.push({ type: 'unsupported', feature: 'stopSequences' });\n    }\n\n    const structuredOutputs = options.structuredOutputs ?? true;\n    const strictJsonSchema = options.strictJsonSchema ?? false;\n\n    // For Mistral we need to need to instruct the model to return a JSON object.\n    // https://docs.mistral.ai/capabilities/structured-output/structured_output_overview/\n    if (responseFormat?.type === 'json' && !responseFormat?.schema) {\n      prompt = injectJsonInstructionIntoMessages({\n        messages: prompt,\n        schema: responseFormat.schema,\n      });\n    }\n\n    const baseArgs = {\n      // model id:\n      model: this.modelId,\n\n      // model specific settings:\n      safe_prompt: options.safePrompt,\n\n      // standardized settings:\n      max_tokens: maxOutputTokens,\n      temperature,\n      top_p: topP,\n      random_seed: seed,\n\n      // response format:\n      response_format:\n        responseFormat?.type === 'json'\n          ? structuredOutputs && responseFormat?.schema != null\n            ? {\n                type: 'json_schema',\n                json_schema: {\n                  schema: responseFormat.schema,\n                  strict: strictJsonSchema,\n                  name: responseFormat.name ?? 'response',\n                  description: responseFormat.description,\n                },\n              }\n            : { type: 'json_object' }\n          : undefined,\n\n      // mistral-specific provider options:\n      document_image_limit: options.documentImageLimit,\n      document_page_limit: options.documentPageLimit,\n\n      // messages:\n      messages: convertToMistralChatMessages(prompt),\n    };\n\n    const {\n      tools: mistralTools,\n      toolChoice: mistralToolChoice,\n      toolWarnings,\n    } = prepareTools({\n      tools,\n      toolChoice,\n    });\n\n    return {\n      args: {\n        ...baseArgs,\n        tools: mistralTools,\n        tool_choice: mistralToolChoice,\n        ...(mistralTools != null && options.parallelToolCalls !== undefined\n          ? { parallel_tool_calls: options.parallelToolCalls }\n          : {}),\n      },\n      warnings: [...warnings, ...toolWarnings],\n    };\n  }\n\n  async doGenerate(\n    options: LanguageModelV3CallOptions,\n  ): Promise<LanguageModelV3GenerateResult> {\n    const { args: body, warnings } = await this.getArgs(options);\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue: rawResponse,\n    } = await postJsonToApi({\n      url: `${this.config.baseURL}/chat/completions`,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: mistralFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        mistralChatResponseSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    const choice = response.choices[0];\n    const content: Array<LanguageModelV3Content> = [];\n\n    // process content parts in order to preserve sequence\n    if (\n      choice.message.content != null &&\n      Array.isArray(choice.message.content)\n    ) {\n      for (const part of choice.message.content) {\n        if (part.type === 'thinking') {\n          const reasoningText = extractReasoningContent(part.thinking);\n          if (reasoningText.length > 0) {\n            content.push({ type: 'reasoning', text: reasoningText });\n          }\n        } else if (part.type === 'text') {\n          if (part.text.length > 0) {\n            content.push({ type: 'text', text: part.text });\n          }\n        }\n      }\n    } else {\n      // handle legacy string content\n      const text = extractTextContent(choice.message.content);\n      if (text != null && text.length > 0) {\n        content.push({ type: 'text', text });\n      }\n    }\n\n    // when there is a trailing assistant message, mistral will send the\n    // content of that message again. we skip this repeated content to\n    // avoid duplication, e.g. in continuation mode.\n\n    // tool calls:\n    if (choice.message.tool_calls != null) {\n      for (const toolCall of choice.message.tool_calls) {\n        content.push({\n          type: 'tool-call',\n          toolCallId: toolCall.id,\n          toolName: toolCall.function.name,\n          input: toolCall.function.arguments!,\n        });\n      }\n    }\n\n    return {\n      content,\n      finishReason: {\n        unified: mapMistralFinishReason(choice.finish_reason),\n        raw: choice.finish_reason ?? undefined,\n      },\n      usage: convertMistralUsage(response.usage),\n      request: { body },\n      response: {\n        ...getResponseMetadata(response),\n        headers: responseHeaders,\n        body: rawResponse,\n      },\n      warnings,\n    };\n  }\n\n  async doStream(\n    options: LanguageModelV3CallOptions,\n  ): Promise<LanguageModelV3StreamResult> {\n    const { args, warnings } = await this.getArgs(options);\n    const body = { ...args, stream: true };\n\n    const { responseHeaders, value: response } = await postJsonToApi({\n      url: `${this.config.baseURL}/chat/completions`,\n      headers: combineHeaders(this.config.headers(), options.headers),\n      body,\n      failedResponseHandler: mistralFailedResponseHandler,\n      successfulResponseHandler: createEventSourceResponseHandler(\n        mistralChatChunkSchema,\n      ),\n      abortSignal: options.abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    let finishReason: LanguageModelV3FinishReason = {\n      unified: 'other',\n      raw: undefined,\n    };\n    let usage: MistralUsage | undefined = undefined;\n\n    let isFirstChunk = true;\n    let activeText = false;\n    let activeReasoningId: string | null = null;\n\n    const generateId = this.generateId;\n\n    return {\n      stream: response.pipeThrough(\n        new TransformStream<\n          ParseResult<z.infer<typeof mistralChatChunkSchema>>,\n          LanguageModelV3StreamPart\n        >({\n          start(controller) {\n            controller.enqueue({ type: 'stream-start', warnings });\n          },\n\n          transform(chunk, controller) {\n            // Emit raw chunk if requested (before anything else)\n            if (options.includeRawChunks) {\n              controller.enqueue({ type: 'raw', rawValue: chunk.rawValue });\n            }\n\n            if (!chunk.success) {\n              controller.enqueue({ type: 'error', error: chunk.error });\n              return;\n            }\n\n            const value = chunk.value;\n\n            if (isFirstChunk) {\n              isFirstChunk = false;\n\n              controller.enqueue({\n                type: 'response-metadata',\n                ...getResponseMetadata(value),\n              });\n            }\n\n            if (value.usage != null) {\n              usage = value.usage;\n            }\n\n            const choice = value.choices[0];\n            const delta = choice.delta;\n\n            const textContent = extractTextContent(delta.content);\n\n            if (delta.content != null && Array.isArray(delta.content)) {\n              for (const part of delta.content) {\n                if (part.type === 'thinking') {\n                  const reasoningDelta = extractReasoningContent(part.thinking);\n                  if (reasoningDelta.length > 0) {\n                    if (activeReasoningId == null) {\n                      // end any active text before starting reasoning\n                      if (activeText) {\n                        controller.enqueue({ type: 'text-end', id: '0' });\n                        activeText = false;\n                      }\n\n                      activeReasoningId = generateId();\n                      controller.enqueue({\n                        type: 'reasoning-start',\n                        id: activeReasoningId,\n                      });\n                    }\n                    controller.enqueue({\n                      type: 'reasoning-delta',\n                      id: activeReasoningId,\n                      delta: reasoningDelta,\n                    });\n                  }\n                }\n              }\n            }\n\n            if (textContent != null && textContent.length > 0) {\n              if (!activeText) {\n                // if we were in reasoning mode, end it before starting text\n                if (activeReasoningId != null) {\n                  controller.enqueue({\n                    type: 'reasoning-end',\n                    id: activeReasoningId,\n                  });\n                  activeReasoningId = null;\n                }\n                controller.enqueue({ type: 'text-start', id: '0' });\n                activeText = true;\n              }\n\n              controller.enqueue({\n                type: 'text-delta',\n                id: '0',\n                delta: textContent,\n              });\n            }\n\n            if (delta?.tool_calls != null) {\n              for (const toolCall of delta.tool_calls) {\n                const toolCallId = toolCall.id;\n                const toolName = toolCall.function.name;\n                const input = toolCall.function.arguments;\n\n                controller.enqueue({\n                  type: 'tool-input-start',\n                  id: toolCallId,\n                  toolName,\n                });\n\n                controller.enqueue({\n                  type: 'tool-input-delta',\n                  id: toolCallId,\n                  delta: input,\n                });\n\n                controller.enqueue({\n                  type: 'tool-input-end',\n                  id: toolCallId,\n                });\n\n                controller.enqueue({\n                  type: 'tool-call',\n                  toolCallId,\n                  toolName,\n                  input,\n                });\n              }\n            }\n\n            if (choice.finish_reason != null) {\n              finishReason = {\n                unified: mapMistralFinishReason(choice.finish_reason),\n                raw: choice.finish_reason,\n              };\n            }\n          },\n\n          flush(controller) {\n            if (activeReasoningId != null) {\n              controller.enqueue({\n                type: 'reasoning-end',\n                id: activeReasoningId,\n              });\n            }\n            if (activeText) {\n              controller.enqueue({ type: 'text-end', id: '0' });\n            }\n\n            controller.enqueue({\n              type: 'finish',\n              finishReason,\n              usage: convertMistralUsage(usage),\n            });\n          },\n        }),\n      ),\n      request: { body },\n      response: { headers: responseHeaders },\n    };\n  }\n}\n\nfunction extractReasoningContent(\n  thinking: Array<{ type: string; text: string }>,\n) {\n  return thinking\n    .filter(chunk => chunk.type === 'text')\n    .map(chunk => chunk.text)\n    .join('');\n}\n\nfunction extractTextContent(content: z.infer<typeof mistralContentSchema>) {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (content == null) {\n    return undefined;\n  }\n\n  const textContent: string[] = [];\n\n  for (const chunk of content) {\n    const { type } = chunk;\n\n    switch (type) {\n      case 'text':\n        textContent.push(chunk.text);\n        break;\n      case 'thinking':\n      case 'image_url':\n      case 'reference':\n        // thinking, image content, and reference content are currently ignored\n        break;\n      default: {\n        const _exhaustiveCheck: never = type;\n        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return textContent.length ? textContent.join('') : undefined;\n}\n\nconst mistralContentSchema = z\n  .union([\n    z.string(),\n    z.array(\n      z.discriminatedUnion('type', [\n        z.object({\n          type: z.literal('text'),\n          text: z.string(),\n        }),\n        z.object({\n          type: z.literal('image_url'),\n          image_url: z.union([\n            z.string(),\n            z.object({\n              url: z.string(),\n              detail: z.string().nullable(),\n            }),\n          ]),\n        }),\n        z.object({\n          type: z.literal('reference'),\n          reference_ids: z.array(z.number()),\n        }),\n        z.object({\n          type: z.literal('thinking'),\n          thinking: z.array(\n            z.object({\n              type: z.literal('text'),\n              text: z.string(),\n            }),\n          ),\n        }),\n      ]),\n    ),\n  ])\n  .nullish();\n\nconst mistralUsageSchema = z.object({\n  prompt_tokens: z.number(),\n  completion_tokens: z.number(),\n  total_tokens: z.number(),\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst mistralChatResponseSchema = z.object({\n  id: z.string().nullish(),\n  created: z.number().nullish(),\n  model: z.string().nullish(),\n  choices: z.array(\n    z.object({\n      message: z.object({\n        role: z.literal('assistant'),\n        content: mistralContentSchema,\n        tool_calls: z\n          .array(\n            z.object({\n              id: z.string(),\n              function: z.object({ name: z.string(), arguments: z.string() }),\n            }),\n          )\n          .nullish(),\n      }),\n      index: z.number(),\n      finish_reason: z.string().nullish(),\n    }),\n  ),\n  object: z.literal('chat.completion'),\n  usage: mistralUsageSchema,\n});\n\n// limited version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst mistralChatChunkSchema = z.object({\n  id: z.string().nullish(),\n  created: z.number().nullish(),\n  model: z.string().nullish(),\n  choices: z.array(\n    z.object({\n      delta: z.object({\n        role: z.enum(['assistant']).optional(),\n        content: mistralContentSchema,\n        tool_calls: z\n          .array(\n            z.object({\n              id: z.string(),\n              function: z.object({ name: z.string(), arguments: z.string() }),\n            }),\n          )\n          .nullish(),\n      }),\n      finish_reason: z.string().nullish(),\n      index: z.number(),\n    }),\n  ),\n  usage: mistralUsageSchema.nullish(),\n});\n","import { LanguageModelV3Usage } from '@ai-sdk/provider';\n\nexport type MistralUsage = {\n  prompt_tokens: number;\n  completion_tokens: number;\n  total_tokens: number;\n};\n\nexport function convertMistralUsage(\n  usage: MistralUsage | undefined | null,\n): LanguageModelV3Usage {\n  if (usage == null) {\n    return {\n      inputTokens: {\n        total: undefined,\n        noCache: undefined,\n        cacheRead: undefined,\n        cacheWrite: undefined,\n      },\n      outputTokens: {\n        total: undefined,\n        text: undefined,\n        reasoning: undefined,\n      },\n      raw: undefined,\n    };\n  }\n\n  const promptTokens = usage.prompt_tokens;\n  const completionTokens = usage.completion_tokens;\n\n  return {\n    inputTokens: {\n      total: promptTokens,\n      noCache: promptTokens,\n      cacheRead: undefined,\n      cacheWrite: undefined,\n    },\n    outputTokens: {\n      total: completionTokens,\n      text: completionTokens,\n      reasoning: undefined,\n    },\n    raw: usage,\n  };\n}\n","import {\n  LanguageModelV3DataContent,\n  LanguageModelV3Prompt,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { MistralPrompt } from './mistral-chat-prompt';\nimport { convertToBase64 } from '@ai-sdk/provider-utils';\n\nfunction formatFileUrl({\n  data,\n  mediaType,\n}: {\n  data: LanguageModelV3DataContent;\n  mediaType: string;\n}): string {\n  return data instanceof URL\n    ? data.toString()\n    : `data:${mediaType};base64,${convertToBase64(data as Uint8Array)}`;\n}\n\nexport function convertToMistralChatMessages(\n  prompt: LanguageModelV3Prompt,\n): MistralPrompt {\n  const messages: MistralPrompt = [];\n\n  for (let i = 0; i < prompt.length; i++) {\n    const { role, content } = prompt[i];\n    const isLastMessage = i === prompt.length - 1;\n\n    switch (role) {\n      case 'system': {\n        messages.push({ role: 'system', content });\n        break;\n      }\n\n      case 'user': {\n        messages.push({\n          role: 'user',\n          content: content.map(part => {\n            switch (part.type) {\n              case 'text': {\n                return { type: 'text', text: part.text };\n              }\n\n              case 'file': {\n                if (part.mediaType.startsWith('image/')) {\n                  const mediaType =\n                    part.mediaType === 'image/*'\n                      ? 'image/jpeg'\n                      : part.mediaType;\n\n                  return {\n                    type: 'image_url',\n                    image_url: formatFileUrl({ data: part.data, mediaType }),\n                  };\n                } else if (part.mediaType === 'application/pdf') {\n                  return {\n                    type: 'document_url',\n                    document_url: formatFileUrl({\n                      data: part.data,\n                      mediaType: 'application/pdf',\n                    }),\n                  };\n                } else {\n                  throw new UnsupportedFunctionalityError({\n                    functionality:\n                      'Only images and PDF file parts are supported',\n                  });\n                }\n              }\n            }\n          }),\n        });\n        break;\n      }\n\n      case 'assistant': {\n        let text = '';\n        const toolCalls: Array<{\n          id: string;\n          type: 'function';\n          function: { name: string; arguments: string };\n        }> = [];\n\n        for (const part of content) {\n          switch (part.type) {\n            case 'text': {\n              text += part.text;\n              break;\n            }\n            case 'tool-call': {\n              toolCalls.push({\n                id: part.toolCallId,\n                type: 'function',\n                function: {\n                  name: part.toolName,\n                  arguments: JSON.stringify(part.input),\n                },\n              });\n              break;\n            }\n            case 'reasoning': {\n              text += part.text;\n              break;\n            }\n            default: {\n              throw new Error(\n                `Unsupported content type in assistant message: ${part.type}`,\n              );\n            }\n          }\n        }\n\n        messages.push({\n          role: 'assistant',\n          content: text,\n          prefix: isLastMessage ? true : undefined,\n          tool_calls: toolCalls.length > 0 ? toolCalls : undefined,\n        });\n\n        break;\n      }\n      case 'tool': {\n        for (const toolResponse of content) {\n          if (toolResponse.type === 'tool-approval-response') {\n            continue;\n          }\n          const output = toolResponse.output;\n\n          let contentValue: string;\n          switch (output.type) {\n            case 'text':\n            case 'error-text':\n              contentValue = output.value;\n              break;\n            case 'execution-denied':\n              contentValue = output.reason ?? 'Tool execution denied.';\n              break;\n            case 'content':\n            case 'json':\n            case 'error-json':\n              contentValue = JSON.stringify(output.value);\n              break;\n          }\n\n          messages.push({\n            role: 'tool',\n            name: toolResponse.toolName,\n            tool_call_id: toolResponse.toolCallId,\n            content: contentValue,\n          });\n        }\n        break;\n      }\n      default: {\n        const _exhaustiveCheck: never = role;\n        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return messages;\n}\n","export function getResponseMetadata({\n  id,\n  model,\n  created,\n}: {\n  id?: string | undefined | null;\n  created?: number | undefined | null;\n  model?: string | undefined | null;\n}) {\n  return {\n    id: id ?? undefined,\n    modelId: model ?? undefined,\n    timestamp: created != null ? new Date(created * 1000) : undefined,\n  };\n}\n","import { LanguageModelV3FinishReason } from '@ai-sdk/provider';\n\nexport function mapMistralFinishReason(\n  finishReason: string | null | undefined,\n): LanguageModelV3FinishReason['unified'] {\n  switch (finishReason) {\n    case 'stop':\n      return 'stop';\n    case 'length':\n    case 'model_length':\n      return 'length';\n    case 'tool_calls':\n      return 'tool-calls';\n    default:\n      return 'other';\n  }\n}\n","import { z } from 'zod/v4';\n\n// https://docs.mistral.ai/getting-started/models/models_overview/\nexport type MistralChatModelId =\n  // premier\n  | 'ministral-3b-latest'\n  | 'ministral-8b-latest'\n  | 'mistral-large-latest'\n  | 'mistral-medium-latest'\n  | 'mistral-medium-2508'\n  | 'mistral-medium-2505'\n  | 'mistral-small-latest'\n  | 'pixtral-large-latest'\n  // reasoning models\n  | 'magistral-small-2507'\n  | 'magistral-medium-2507'\n  | 'magistral-small-2506'\n  | 'magistral-medium-2506'\n  // free\n  | 'pixtral-12b-2409'\n  // legacy\n  | 'open-mistral-7b'\n  | 'open-mixtral-8x7b'\n  | 'open-mixtral-8x22b'\n  | (string & {});\n\nexport const mistralLanguageModelOptions = z.object({\n  /**\nWhether to inject a safety prompt before all conversations.\n\nDefaults to `false`.\n   */\n  safePrompt: z.boolean().optional(),\n\n  documentImageLimit: z.number().optional(),\n  documentPageLimit: z.number().optional(),\n\n  /**\n   * Whether to use structured outputs.\n   *\n   * @default true\n   */\n  structuredOutputs: z.boolean().optional(),\n\n  /**\n   * Whether to use strict JSON schema validation.\n   *\n   * @default false\n   */\n  strictJsonSchema: z.boolean().optional(),\n\n  /**\n   * Whether to enable parallel function calling during tool use.\n   * When set to false, the model will use at most one tool per response.\n   *\n   * @default true\n   */\n  parallelToolCalls: z.boolean().optional(),\n});\n\nexport type MistralLanguageModelOptions = z.infer<\n  typeof mistralLanguageModelOptions\n>;\n","import { createJsonErrorResponseHandler } from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\n\nconst mistralErrorDataSchema = z.object({\n  object: z.literal('error'),\n  message: z.string(),\n  type: z.string(),\n  param: z.string().nullable(),\n  code: z.string().nullable(),\n});\n\nexport type MistralErrorData = z.infer<typeof mistralErrorDataSchema>;\n\nexport const mistralFailedResponseHandler = createJsonErrorResponseHandler({\n  errorSchema: mistralErrorDataSchema,\n  errorToMessage: data => data.message,\n});\n","import {\n  LanguageModelV3CallOptions,\n  SharedV3Warning,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport { MistralToolChoice } from './mistral-chat-prompt';\n\nexport function prepareTools({\n  tools,\n  toolChoice,\n}: {\n  tools: LanguageModelV3CallOptions['tools'];\n  toolChoice?: LanguageModelV3CallOptions['toolChoice'];\n}): {\n  tools:\n    | Array<{\n        type: 'function';\n        function: {\n          name: string;\n          description: string | undefined;\n          parameters: unknown;\n          strict?: boolean;\n        };\n      }>\n    | undefined;\n  toolChoice: MistralToolChoice | undefined;\n  toolWarnings: SharedV3Warning[];\n} {\n  // when the tools array is empty, change it to undefined to prevent errors:\n  tools = tools?.length ? tools : undefined;\n\n  const toolWarnings: SharedV3Warning[] = [];\n\n  if (tools == null) {\n    return { tools: undefined, toolChoice: undefined, toolWarnings };\n  }\n\n  const mistralTools: Array<{\n    type: 'function';\n    function: {\n      name: string;\n      description: string | undefined;\n      parameters: unknown;\n      strict?: boolean;\n    };\n  }> = [];\n\n  for (const tool of tools) {\n    if (tool.type === 'provider') {\n      toolWarnings.push({\n        type: 'unsupported',\n        feature: `provider-defined tool ${tool.id}`,\n      });\n    } else {\n      mistralTools.push({\n        type: 'function',\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: tool.inputSchema,\n          ...(tool.strict != null ? { strict: tool.strict } : {}),\n        },\n      });\n    }\n  }\n\n  if (toolChoice == null) {\n    return { tools: mistralTools, toolChoice: undefined, toolWarnings };\n  }\n\n  const type = toolChoice.type;\n\n  switch (type) {\n    case 'auto':\n    case 'none':\n      return { tools: mistralTools, toolChoice: type, toolWarnings };\n    case 'required':\n      return { tools: mistralTools, toolChoice: 'any', toolWarnings };\n\n    // mistral does not support tool mode directly,\n    // so we filter the tools and force the tool choice through 'any'\n    case 'tool':\n      return {\n        tools: mistralTools.filter(\n          tool => tool.function.name === toolChoice.toolName,\n        ),\n        toolChoice: 'any',\n        toolWarnings,\n      };\n    default: {\n      const _exhaustiveCheck: never = type;\n      throw new UnsupportedFunctionalityError({\n        functionality: `tool choice type: ${_exhaustiveCheck}`,\n      });\n    }\n  }\n}\n","import {\n  EmbeddingModelV3,\n  TooManyEmbeddingValuesForCallError,\n} from '@ai-sdk/provider';\nimport {\n  combineHeaders,\n  createJsonResponseHandler,\n  FetchFunction,\n  postJsonToApi,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { MistralEmbeddingModelId } from './mistral-embedding-options';\nimport { mistralFailedResponseHandler } from './mistral-error';\n\ntype MistralEmbeddingConfig = {\n  provider: string;\n  baseURL: string;\n  headers: () => Record<string, string | undefined>;\n  fetch?: FetchFunction;\n};\n\nexport class MistralEmbeddingModel implements EmbeddingModelV3 {\n  readonly specificationVersion = 'v3';\n  readonly modelId: MistralEmbeddingModelId;\n  readonly maxEmbeddingsPerCall = 32;\n  readonly supportsParallelCalls = false;\n\n  private readonly config: MistralEmbeddingConfig;\n\n  get provider(): string {\n    return this.config.provider;\n  }\n\n  constructor(\n    modelId: MistralEmbeddingModelId,\n    config: MistralEmbeddingConfig,\n  ) {\n    this.modelId = modelId;\n    this.config = config;\n  }\n\n  async doEmbed({\n    values,\n    abortSignal,\n    headers,\n  }: Parameters<EmbeddingModelV3['doEmbed']>[0]): Promise<\n    Awaited<ReturnType<EmbeddingModelV3['doEmbed']>>\n  > {\n    if (values.length > this.maxEmbeddingsPerCall) {\n      throw new TooManyEmbeddingValuesForCallError({\n        provider: this.provider,\n        modelId: this.modelId,\n        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n        values,\n      });\n    }\n\n    const {\n      responseHeaders,\n      value: response,\n      rawValue,\n    } = await postJsonToApi({\n      url: `${this.config.baseURL}/embeddings`,\n      headers: combineHeaders(this.config.headers(), headers),\n      body: {\n        model: this.modelId,\n        input: values,\n        encoding_format: 'float',\n      },\n      failedResponseHandler: mistralFailedResponseHandler,\n      successfulResponseHandler: createJsonResponseHandler(\n        MistralTextEmbeddingResponseSchema,\n      ),\n      abortSignal,\n      fetch: this.config.fetch,\n    });\n\n    return {\n      warnings: [],\n      embeddings: response.data.map(item => item.embedding),\n      usage: response.usage\n        ? { tokens: response.usage.prompt_tokens }\n        : undefined,\n      response: { headers: responseHeaders, body: rawValue },\n    };\n  }\n}\n\n// minimal version of the schema, focussed on what is needed for the implementation\n// this approach limits breakages when the API changes and increases efficiency\nconst MistralTextEmbeddingResponseSchema = z.object({\n  data: z.array(z.object({ embedding: z.array(z.number()) })),\n  usage: z.object({ prompt_tokens: z.number() }).nullish(),\n});\n","// Version string of this package injected at build time.\ndeclare const __PACKAGE_VERSION__: string | undefined;\nexport const VERSION: string =\n  typeof __PACKAGE_VERSION__ !== 'undefined'\n    ? __PACKAGE_VERSION__\n    : '0.0.0-test';\n"],"mappings":"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","names":["z","z","z","UnsupportedFunctionalityError","generateId","postJsonToApi","combineHeaders","createJsonResponseHandler"]}