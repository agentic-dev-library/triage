{"version":3,"sources":["../src/octokit.ts"],"sourcesContent":["/**\n * GitHub Operations via MCP\n *\n * All GitHub operations using GitHub MCP - no HTTP/fetch from this process.\n * The MCP server handles HTTP to GitHub API via subprocess communication.\n *\n * This module provides:\n * - Singleton GitHub MCP client management\n * - Convenience wrappers around MCP tool calls\n * - Repository context from git/environment\n */\n\nimport { execSync } from 'node:child_process';\nimport { createGitHubClient, createGraphQLClient, type MCPClient } from './mcp.js';\n\n// Singleton MCP clients\nlet _githubClient: MCPClient | null = null;\nlet _clientPromise: Promise<MCPClient> | null = null;\nlet _graphqlClient: MCPClient | null = null;\nlet _graphqlPromise: Promise<MCPClient> | null = null;\n\n/**\n * Get or create the singleton GitHub MCP client\n */\nexport async function getGitHubMCPClient(): Promise<MCPClient> {\n    if (_githubClient) return _githubClient;\n\n    if (!_clientPromise) {\n        _clientPromise = createGitHubClient().then((client) => {\n            _githubClient = client;\n            return client;\n        });\n    }\n\n    return _clientPromise;\n}\n\n/**\n * Close the GitHub MCP client (call on shutdown)\n */\nexport async function closeGitHubClient(): Promise<void> {\n    if (_githubClient) {\n        await _githubClient.close();\n        _githubClient = null;\n        _clientPromise = null;\n    }\n}\n\n/**\n * Get or create the singleton GraphQL MCP client\n */\nexport async function getGraphQLMCPClient(): Promise<MCPClient> {\n    if (_graphqlClient) return _graphqlClient;\n\n    if (!_graphqlPromise) {\n        _graphqlPromise = createGraphQLClient().then((client) => {\n            _graphqlClient = client;\n            return client;\n        });\n    }\n\n    return _graphqlPromise;\n}\n\n/**\n * Close the GraphQL MCP client (call on shutdown)\n */\nexport async function closeGraphQLClient(): Promise<void> {\n    if (_graphqlClient) {\n        await _graphqlClient.close();\n        _graphqlClient = null;\n        _graphqlPromise = null;\n    }\n}\n\n/**\n * Close all MCP clients (call on shutdown)\n */\nexport async function closeAllClients(): Promise<void> {\n    await Promise.all([closeGitHubClient(), closeGraphQLClient()]);\n}\n\n/**\n * Execute a GraphQL query/mutation via MCP\n *\n * @param query - The GraphQL query or mutation string\n * @param variables - Variables for the query\n * @returns The query result data\n */\nexport async function executeGraphQL<T = unknown>(query: string, variables?: Record<string, unknown>): Promise<T> {\n    const client = await getGraphQLMCPClient();\n    const tools = await client.tools();\n\n    // mcp-graphql exposes 'query-graphql' tool for executing queries\n    const tool = tools['query-graphql'] || tools.graphql || tools.execute || tools.query;\n    if (!tool) {\n        throw new Error(`GraphQL MCP tool not found. Available tools: ${Object.keys(tools).join(', ')}`);\n    }\n\n    if (typeof tool.execute !== 'function') {\n        throw new Error('GraphQL MCP tool is not executable');\n    }\n\n    // mcp-graphql expects variables as a JSON string, not an object\n    const args: { query: string; variables?: string } = { query };\n    if (variables && Object.keys(variables).length > 0) {\n        args.variables = JSON.stringify(variables);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const result = await (tool.execute as any)(args);\n    const data = parseGraphQLResponse(result);\n\n    if (data.errors && data.errors.length > 0) {\n        throw new Error(`GraphQL error: ${data.errors.map((e: { message: string }) => e.message).join(', ')}`);\n    }\n    return (data.data || data) as T;\n}\n\n/**\n * Parse the response from the GraphQL MCP tool\n */\nfunction parseGraphQLResponse(result: any): any {\n    // Handle response format from mcp-graphql (may have content array)\n    if (result.content && Array.isArray(result.content)) {\n        const textContent = result.content.find((c: { type: string }) => c.type === 'text');\n        if (textContent?.text) {\n            return JSON.parse(textContent.text);\n        }\n    }\n    return result;\n}\n\n/**\n * Call a GitHub MCP tool\n */\nasync function callGitHubTool(toolName: string, args: Record<string, unknown>): Promise<unknown> {\n    const client = await getGitHubMCPClient();\n    const tools = await client.tools();\n\n    const tool = tools[toolName];\n    if (!tool) {\n        throw new Error(`GitHub MCP tool '${toolName}' not found`);\n    }\n\n    // Call the tool's execute function\n    // Use type assertion since MCP tools have different signatures\n    if (typeof tool.execute === 'function') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return (tool.execute as any)(args);\n    }\n\n    throw new Error(`GitHub MCP tool '${toolName}' is not executable`);\n}\n\n/**\n * Get repository context from environment or git\n * This does NOT require MCP - uses local git commands\n */\nexport function getRepoContext(): { owner: string; repo: string } {\n    // First try environment variable (CI environments)\n    const repository = process.env.GITHUB_REPOSITORY;\n    if (repository) {\n        const [owner, repo] = repository.split('/');\n        return { owner, repo };\n    }\n\n    // Fall back to git remote\n    try {\n        const remote = execSync('git remote get-url origin', {\n            encoding: 'utf-8',\n            stdio: ['pipe', 'pipe', 'pipe'],\n        }).trim();\n\n        // Parse GitHub URL formats:\n        // https://github.com/owner/repo.git\n        // git@github.com:owner/repo.git\n        const httpsMatch = remote.match(/github\\.com\\/([^/]+)\\/([^/.]+)/);\n        const sshMatch = remote.match(/github\\.com:([^/]+)\\/([^/.]+)/);\n\n        const match = httpsMatch || sshMatch;\n        if (match) {\n            return { owner: match[1], repo: match[2] };\n        }\n    } catch {\n        // Git command failed\n    }\n\n    throw new Error(\n        'Could not determine repository context. Set GITHUB_REPOSITORY or ensure git remote is configured.'\n    );\n}\n\n// Re-export for compatibility\nexport function getOctokit(): never {\n    throw new Error(\n        'Octokit is deprecated. Use GitHub MCP functions instead:\\n' +\n            '- getGitHubMCPClient() for direct MCP access\\n' +\n            '- callGitHubTool() for tool invocation\\n' +\n            '- Or use runAgenticTask() from mcp.ts for AI-driven operations'\n    );\n}\n\n// ============================================\n// HIGH-LEVEL GITHUB MCP WRAPPERS\n// ============================================\n\n/**\n * Get issue details via MCP\n */\nexport async function getIssue(\n    issueNumber: number,\n    repoContext?: { owner: string; repo: string }\n): Promise<{\n    number: number;\n    title: string;\n    body: string;\n    state: string;\n    labels: string[];\n}> {\n    const { owner, repo } = repoContext || getRepoContext();\n    const result = (await callGitHubTool('get_issue', {\n        owner,\n        repo,\n        issue_number: issueNumber,\n    })) as {\n        number: number;\n        title: string;\n        body: string;\n        state: string;\n        labels?: Array<{ name: string }>;\n    };\n\n    return {\n        number: result.number,\n        title: result.title,\n        body: result.body || '',\n        state: result.state,\n        labels: result.labels?.map((l) => l.name) || [],\n    };\n}\n\n/**\n * Create a comment on an issue or PR via MCP.\n *\n * Notes:\n * - GitHub treats PR comments as \"issue comments\" on the PR's issue thread.\n */\nexport async function addIssueComment(issueNumber: number, body: string): Promise<void> {\n    const { owner, repo } = getRepoContext();\n    await callGitHubTool('add_issue_comment', {\n        owner,\n        repo,\n        issue_number: issueNumber,\n        body,\n    });\n}\n\n/**\n * @deprecated Use addIssueComment()\n */\nexport async function createIssueComment(issueNumber: number, body: string): Promise<void> {\n    return addIssueComment(issueNumber, body);\n}\n\n/**\n * Create an issue via MCP\n */\nexport async function createIssue(\n    issue: {\n        title: string;\n        body: string;\n        labels?: string[];\n        assignees?: string[];\n    },\n    repoContext?: { owner: string; repo: string }\n): Promise<{ number: number }> {\n    const { owner, repo } = repoContext || getRepoContext();\n    const result = (await callGitHubTool('create_issue', {\n        owner,\n        repo,\n        ...issue,\n    })) as { number: number };\n    return { number: result.number };\n}\n\n/**\n * Update an issue via MCP\n */\nexport async function updateIssue(\n    issueNumber: number,\n    updates: {\n        title?: string;\n        body?: string;\n        state?: 'open' | 'closed';\n        labels?: string[];\n        assignees?: string[];\n    },\n    repoContext?: { owner: string; repo: string }\n): Promise<void> {\n    const { owner, repo } = repoContext || getRepoContext();\n    await callGitHubTool('update_issue', {\n        owner,\n        repo,\n        issue_number: issueNumber,\n        ...updates,\n    });\n}\n\n/**\n * Add labels to an issue without clobbering existing labels.\n */\nexport async function addIssueLabels(issueNumber: number, labels: string[]): Promise<void> {\n    if (labels.length === 0) return;\n    const issue = await getIssue(issueNumber);\n    const merged = Array.from(new Set([...issue.labels, ...labels]));\n    await updateIssue(issueNumber, { labels: merged });\n}\n\n/**\n * Comment on a PR (issue comment thread).\n */\nexport async function commentOnPR(prNumber: number, body: string): Promise<void> {\n    return addIssueComment(prNumber, body);\n}\n\n/**\n * Search issues via MCP (REST API)\n *\n * Note: This may not work with GitHub App tokens that have limited scopes.\n * Prefer searchIssuesGraphQL for better compatibility.\n */\nexport async function searchIssues(\n    query: string,\n    repoContext?: { owner: string; repo: string }\n): Promise<\n    Array<{\n        number: number;\n        title: string;\n        state: string;\n        labels: string[];\n    }>\n> {\n    // Try GraphQL first (more reliable with GitHub App tokens)\n    try {\n        return await searchIssuesGraphQL(query, {}, repoContext);\n    } catch (error) {\n        // Fall back to REST API, but log the GraphQL error for debugging\n        console.warn('GraphQL search failed, falling back to REST API. Error:', error);\n    }\n\n    const { owner, repo } = repoContext || getRepoContext();\n    const fullQuery = `repo:${owner}/${repo} ${query}`;\n\n    const result = (await callGitHubTool('search_issues', {\n        query: fullQuery,\n    })) as {\n        items?: Array<{\n            number: number;\n            title: string;\n            state: string;\n            labels?: Array<{ name: string }>;\n        }>;\n    };\n\n    return (result.items || []).map((item) => ({\n        number: item.number,\n        title: item.title,\n        state: item.state,\n        labels: item.labels?.map((l) => l.name) || [],\n    }));\n}\n\n/**\n * Search issues via GraphQL (preferred method)\n *\n * Works reliably with GitHub App tokens that may have limited REST API access.\n */\nexport async function searchIssuesGraphQL(\n    query: string,\n    options: { first?: number; includeBody?: boolean } = {},\n    repoContext?: { owner: string; repo: string }\n): Promise<\n    Array<{\n        number: number;\n        title: string;\n        state: string;\n        labels: string[];\n        body?: string;\n    }>\n> {\n    const { owner, repo } = repoContext || getRepoContext();\n    const { first = 100, includeBody = false } = options;\n\n    // Parse query for state filter\n    const isOpen = query.includes('is:open') || query.includes('state:open');\n    const isClosed = query.includes('is:closed') || query.includes('state:closed');\n    const states = isClosed ? 'CLOSED' : isOpen ? 'OPEN' : null;\n\n    // Use proper GraphQL variables instead of string interpolation for robustness\n    const gqlQuery = `\n        query GetIssues($owner: String!, $repo: String!, $first: Int!, $states: [IssueState!], $includeBody: Boolean!) {\n            repository(owner: $owner, name: $repo) {\n                issues(first: $first, orderBy: {field: UPDATED_AT, direction: DESC}, states: $states) {\n                    nodes {\n                        number\n                        title\n                        state\n                        body @include(if: $includeBody)\n                        labels(first: 10) {\n                            nodes {\n                                name\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    `;\n\n    const variables: Record<string, unknown> = { owner, repo, first, includeBody };\n    if (states) {\n        variables.states = [states];\n    }\n\n    const result = await executeGraphQL<{\n        repository: {\n            issues: {\n                nodes: Array<{\n                    number: number;\n                    title: string;\n                    state: string;\n                    body?: string;\n                    labels: { nodes: Array<{ name: string }> };\n                }>;\n            };\n        };\n    }>(gqlQuery, variables);\n\n    return result.repository.issues.nodes.map((issue) => ({\n        number: issue.number,\n        title: issue.title,\n        state: issue.state.toLowerCase(),\n        labels: issue.labels.nodes.map((l) => l.name),\n        ...(includeBody && { body: issue.body }),\n    }));\n}\n\n/**\n * Get pull request details via MCP\n */\nexport async function getPullRequest(prNumber: number): Promise<{\n    number: number;\n    title: string;\n    body: string;\n    state: string;\n    head: { ref: string; sha: string };\n    base: { ref: string };\n    draft: boolean;\n    mergeable: boolean | null;\n}> {\n    const { owner, repo } = getRepoContext();\n    const result = (await callGitHubTool('get_pull_request', {\n        owner,\n        repo,\n        pull_number: prNumber,\n    })) as {\n        number: number;\n        title: string;\n        body: string;\n        state: string;\n        head: { ref: string; sha: string };\n        base: { ref: string };\n        draft: boolean;\n        mergeable: boolean | null;\n    };\n\n    return result;\n}\n\n/**\n * List commits on a branch via MCP\n */\nexport async function listCommits(\n    branch: string,\n    options: { per_page?: number } = {}\n): Promise<\n    Array<{\n        sha: string;\n        message: string;\n        author: string;\n    }>\n> {\n    const { owner, repo } = getRepoContext();\n    const result = (await callGitHubTool('list_commits', {\n        owner,\n        repo,\n        sha: branch,\n        per_page: options.per_page || 30,\n    })) as Array<{\n        sha: string;\n        commit: { message: string };\n        author?: { login: string };\n    }>;\n\n    return result.map((c) => ({\n        sha: c.sha,\n        message: c.commit.message,\n        author: c.author?.login || 'unknown',\n    }));\n}\n\n/**\n * Get file contents via MCP\n */\nexport async function getFileContents(path: string, options: { ref?: string } = {}): Promise<string> {\n    const { owner, repo } = getRepoContext();\n    const result = (await callGitHubTool('get_file_contents', {\n        owner,\n        repo,\n        path,\n        ref: options.ref,\n    })) as { content?: string; encoding?: string };\n\n    if (result.content && result.encoding === 'base64') {\n        return Buffer.from(result.content, 'base64').toString('utf-8');\n    }\n\n    return result.content || '';\n}\n\n// ============================================\n// LEGACY COMPATIBILITY - Async Versions\n// ============================================\n\n// These maintain the same signatures but are async and use MCP\n\nexport interface ReviewComment {\n    id: number;\n    nodeId: string;\n    body: string;\n    path: string;\n    line?: number;\n    user: string;\n    createdAt: string;\n    state?: string;\n}\n\nexport interface CheckRun {\n    id: number;\n    name: string;\n    status: string;\n    conclusion: string | null;\n    startedAt: string;\n    completedAt: string | null;\n    url: string;\n}\n\nexport interface CodeScanningAlert {\n    number: number;\n    rule: { id: string; name?: string; severity: string; description: string };\n    state: string;\n    tool: string;\n    createdAt: string;\n    url: string;\n    location?: { path: string; startLine: number; endLine: number };\n}\n\nexport interface DependabotAlert {\n    number: number;\n    state: string;\n    dependency: { package: string; ecosystem: string; manifestPath: string };\n    securityAdvisory: { ghsaId: string; severity: string; summary: string };\n    securityVulnerability: {\n        severity: string;\n        vulnerableVersionRange: string;\n        firstPatchedVersion?: string;\n    };\n    createdAt: string;\n    url: string;\n}\n\nexport interface ReviewThread {\n    id: string;\n    isResolved: boolean;\n    isOutdated: boolean;\n    path: string;\n    line: number | null;\n    comments: Array<{\n        id: string;\n        body: string;\n        author: string;\n        createdAt: string;\n    }>;\n}\n\n// ============================================\n// GRAPHQL OPERATIONS (via mcp-graphql)\n// ============================================\n\n/**\n * Get the node ID for a pull request (needed for GraphQL mutations)\n */\nasync function getPRNodeId(prNumber: number): Promise<string> {\n    const { owner, repo } = getRepoContext();\n    const query = `\n        query GetPRNodeId($owner: String!, $repo: String!, $number: Int!) {\n            repository(owner: $owner, name: $repo) {\n                pullRequest(number: $number) {\n                    id\n                }\n            }\n        }\n    `;\n    const result = await executeGraphQL<{\n        repository: { pullRequest: { id: string } };\n    }>(query, { owner, repo, number: prNumber });\n    return result.repository.pullRequest.id;\n}\n\n/**\n * Convert a PR to draft status\n */\nexport async function convertPRToDraft(prNumber: number): Promise<void> {\n    const pullRequestId = await getPRNodeId(prNumber);\n    const mutation = `\n        mutation ConvertToDraft($pullRequestId: ID!) {\n            convertPullRequestToDraft(input: { pullRequestId: $pullRequestId }) {\n                pullRequest {\n                    isDraft\n                }\n            }\n        }\n    `;\n    await executeGraphQL(mutation, { pullRequestId });\n}\n\n/**\n * Enable auto-merge on a PR\n */\nexport async function enableAutoMerge(\n    prNumber: number,\n    mergeMethod: 'MERGE' | 'SQUASH' | 'REBASE' = 'SQUASH'\n): Promise<void> {\n    const pullRequestId = await getPRNodeId(prNumber);\n    const mutation = `\n        mutation EnableAutoMerge($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {\n            enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }) {\n                pullRequest {\n                    autoMergeRequest {\n                        enabledAt\n                    }\n                }\n            }\n        }\n    `;\n    await executeGraphQL(mutation, { pullRequestId, mergeMethod });\n}\n\n/**\n * Disable auto-merge on a PR\n */\nexport async function disableAutoMerge(prNumber: number): Promise<void> {\n    const pullRequestId = await getPRNodeId(prNumber);\n    const mutation = `\n        mutation DisableAutoMerge($pullRequestId: ID!) {\n            disablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId }) {\n                pullRequest {\n                    autoMergeRequest {\n                        enabledAt\n                    }\n                }\n            }\n        }\n    `;\n    await executeGraphQL(mutation, { pullRequestId });\n}\n\n/**\n * Get review comments on a PR\n */\nexport async function getPRReviewComments(prNumber: number): Promise<ReviewComment[]> {\n    const { owner, repo } = getRepoContext();\n    const query = `\n        query GetReviewComments($owner: String!, $repo: String!, $number: Int!) {\n            repository(owner: $owner, name: $repo) {\n                pullRequest(number: $number) {\n                    reviewThreads(first: 100) {\n                        nodes {\n                            path\n                            line\n                            comments(first: 50) {\n                                nodes {\n                                    id\n                                    databaseId\n                                    body\n                                    author {\n                                        login\n                                    }\n                                    createdAt\n                                    state\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    `;\n    const result = await executeGraphQL<{\n        repository: {\n            pullRequest: {\n                reviewThreads: {\n                    nodes: Array<{\n                        path: string;\n                        line: number | null;\n                        comments: {\n                            nodes: Array<{\n                                id: string;\n                                databaseId: number;\n                                body: string;\n                                author: { login: string } | null;\n                                createdAt: string;\n                                state: string;\n                            }>;\n                        };\n                    }>;\n                };\n            };\n        };\n    }>(query, { owner, repo, number: prNumber });\n\n    const comments: ReviewComment[] = [];\n    for (const thread of result.repository.pullRequest.reviewThreads.nodes) {\n        for (const c of thread.comments.nodes) {\n            comments.push({\n                id: c.databaseId,\n                nodeId: c.id,\n                body: c.body,\n                path: thread.path,\n                line: thread.line ?? undefined,\n                user: c.author?.login || 'unknown',\n                createdAt: c.createdAt,\n                state: c.state,\n            });\n        }\n    }\n    return comments;\n}\n\n/**\n * Get reviews on a PR\n */\nexport async function getPRReviews(prNumber: number): Promise<\n    Array<{\n        id: number;\n        user: string;\n        state: string;\n        body: string;\n        submittedAt: string;\n    }>\n> {\n    const { owner, repo } = getRepoContext();\n    const query = `\n        query GetReviews($owner: String!, $repo: String!, $number: Int!) {\n            repository(owner: $owner, name: $repo) {\n                pullRequest(number: $number) {\n                    reviews(first: 100) {\n                        nodes {\n                            databaseId\n                            author {\n                                login\n                            }\n                            state\n                            body\n                            submittedAt\n                        }\n                    }\n                }\n            }\n        }\n    `;\n    const result = await executeGraphQL<{\n        repository: {\n            pullRequest: {\n                reviews: {\n                    nodes: Array<{\n                        databaseId: number;\n                        author: { login: string } | null;\n                        state: string;\n                        body: string;\n                        submittedAt: string;\n                    }>;\n                };\n            };\n        };\n    }>(query, { owner, repo, number: prNumber });\n\n    return result.repository.pullRequest.reviews.nodes.map((r) => ({\n        id: r.databaseId,\n        user: r.author?.login || 'unknown',\n        state: r.state,\n        body: r.body || '',\n        submittedAt: r.submittedAt,\n    }));\n}\n\n/**\n * Reply to a review comment\n *\n * @param prNumber - The PR number\n * @param commentNodeId - The GraphQL node ID of the comment to reply to (from ReviewComment.nodeId)\n * @param body - The reply body\n */\nexport async function replyToReviewComment(prNumber: number, commentNodeId: string, body: string): Promise<void> {\n    const pullRequestId = await getPRNodeId(prNumber);\n    const mutation = `\n        mutation ReplyToComment($pullRequestId: ID!, $body: String!, $inReplyTo: ID!) {\n            addPullRequestReviewComment(input: {\n                pullRequestId: $pullRequestId,\n                body: $body,\n                inReplyTo: $inReplyTo\n            }) {\n                comment {\n                    id\n                }\n            }\n        }\n    `;\n    await executeGraphQL(mutation, {\n        pullRequestId,\n        body,\n        inReplyTo: commentNodeId,\n    });\n}\n\n/**\n * Submit a PR review\n */\nexport async function submitPRReview(\n    prNumber: number,\n    event: 'APPROVE' | 'REQUEST_CHANGES' | 'COMMENT',\n    body: string\n): Promise<void> {\n    const pullRequestId = await getPRNodeId(prNumber);\n    const mutation = `\n        mutation SubmitReview($pullRequestId: ID!, $event: PullRequestReviewEvent!, $body: String!) {\n            addPullRequestReview(input: {\n                pullRequestId: $pullRequestId,\n                event: $event,\n                body: $body\n            }) {\n                pullRequestReview {\n                    id\n                    state\n                }\n            }\n        }\n    `;\n    await executeGraphQL(mutation, { pullRequestId, event, body });\n}\n\n/**\n * Get check runs for a ref\n */\nexport async function getCheckRuns(ref: string): Promise<CheckRun[]> {\n    const { owner, repo } = getRepoContext();\n    const query = `\n        query GetCheckRuns($owner: String!, $repo: String!, $ref: String!) {\n            repository(owner: $owner, name: $repo) {\n                object(expression: $ref) {\n                    ... on Commit {\n                        checkSuites(first: 20) {\n                            nodes {\n                                checkRuns(first: 50) {\n                                    nodes {\n                                        databaseId\n                                        name\n                                        status\n                                        conclusion\n                                        startedAt\n                                        completedAt\n                                        detailsUrl\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    `;\n    const result = await executeGraphQL<{\n        repository: {\n            object: {\n                checkSuites: {\n                    nodes: Array<{\n                        checkRuns: {\n                            nodes: Array<{\n                                databaseId: number;\n                                name: string;\n                                status: string;\n                                conclusion: string | null;\n                                startedAt: string;\n                                completedAt: string | null;\n                                detailsUrl: string;\n                            }>;\n                        };\n                    }>;\n                };\n            };\n        };\n    }>(query, { owner, repo, ref });\n\n    const checkRuns: CheckRun[] = [];\n    for (const suite of result.repository.object?.checkSuites?.nodes || []) {\n        for (const run of suite.checkRuns.nodes) {\n            checkRuns.push({\n                id: run.databaseId,\n                name: run.name,\n                status: run.status,\n                conclusion: run.conclusion,\n                startedAt: run.startedAt,\n                completedAt: run.completedAt,\n                url: run.detailsUrl,\n            });\n        }\n    }\n    return checkRuns;\n}\n\n/**\n * Check if all checks are passing for a ref\n */\nexport async function areAllChecksPassing(ref: string): Promise<{\n    passing: boolean;\n    pending: number;\n    failed: string[];\n}> {\n    const checks = await getCheckRuns(ref);\n\n    const pending = checks.filter((c) => c.status !== 'COMPLETED').length;\n\n    const failed = checks\n        .filter((c) => c.conclusion === 'FAILURE' || c.conclusion === 'TIMED_OUT' || c.conclusion === 'CANCELLED')\n        .map((c) => c.name);\n\n    const passing = failed.length === 0 && pending === 0;\n\n    return { passing, pending, failed };\n}\n\nexport async function createCheckRun(\n    _name: string,\n    _headSha: string,\n    _options?: {\n        status?: 'queued' | 'in_progress' | 'completed';\n        conclusion?: 'success' | 'failure' | 'neutral' | 'cancelled' | 'skipped' | 'timed_out' | 'action_required';\n        title?: string;\n        summary?: string;\n        text?: string;\n    }\n): Promise<number> {\n    throw new Error('createCheckRun not yet available via MCP. Use runAgenticTask.');\n}\n\nexport async function getCodeScanningAlerts(_state?: 'open' | 'dismissed' | 'fixed'): Promise<CodeScanningAlert[]> {\n    throw new Error('getCodeScanningAlerts not yet available via MCP. Use runAgenticTask.');\n}\n\nexport async function getPRCodeScanningAlerts(_prNumber: number): Promise<CodeScanningAlert[]> {\n    throw new Error('getPRCodeScanningAlerts not yet available via MCP. Use runAgenticTask.');\n}\n\nexport async function getDependabotAlerts(_state?: 'open' | 'dismissed' | 'fixed'): Promise<DependabotAlert[]> {\n    throw new Error('getDependabotAlerts not yet available via MCP. Use runAgenticTask.');\n}\n\n/**\n * Wait for checks to complete and return status\n */\nexport async function waitForChecks(\n    ref: string,\n    options?: { timeout?: number; pollInterval?: number }\n): Promise<{ passing: boolean; failed: string[] }> {\n    const timeout = options?.timeout || 300000; // 5 minutes default\n    const pollInterval = options?.pollInterval || 10000; // 10 seconds default\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeout) {\n        const status = await areAllChecksPassing(ref);\n\n        if (status.pending === 0) {\n            return { passing: status.passing, failed: status.failed };\n        }\n\n        // Wait before polling again\n        await new Promise((resolve) => setTimeout(resolve, pollInterval));\n    }\n\n    // Timeout - return current status\n    const finalStatus = await areAllChecksPassing(ref);\n    return { passing: false, failed: [...finalStatus.failed, 'TIMEOUT'] };\n}\n\nexport function formatAlertsForAI(codeScanning: CodeScanningAlert[], dependabot: DependabotAlert[]): string {\n    const lines: string[] = [];\n\n    if (codeScanning.length > 0) {\n        lines.push('## Code Scanning Alerts');\n        for (const alert of codeScanning) {\n            lines.push(`- **${alert.rule.id}** (${alert.rule.severity}): ${alert.rule.description}`);\n            if (alert.location) {\n                lines.push(`  - Location: ${alert.location.path}:${alert.location.startLine}`);\n            }\n        }\n        lines.push('');\n    }\n\n    if (dependabot.length > 0) {\n        lines.push('## Dependabot Alerts');\n        for (const alert of dependabot) {\n            lines.push(`- **${alert.dependency.package}** (${alert.securityVulnerability.severity})`);\n            lines.push(`  - ${alert.securityAdvisory.summary}`);\n            if (alert.securityVulnerability.firstPatchedVersion) {\n                lines.push(`  - Fix: Upgrade to ${alert.securityVulnerability.firstPatchedVersion}`);\n            }\n        }\n        lines.push('');\n    }\n\n    return lines.join('\\n');\n}\n\n/**\n * Get review threads on a PR\n */\nexport async function getPRReviewThreads(prNumber: number): Promise<ReviewThread[]> {\n    const { owner, repo } = getRepoContext();\n    const query = `\n        query GetReviewThreads($owner: String!, $repo: String!, $number: Int!) {\n            repository(owner: $owner, name: $repo) {\n                pullRequest(number: $number) {\n                    reviewThreads(first: 100) {\n                        nodes {\n                            id\n                            isResolved\n                            isOutdated\n                            path\n                            line\n                            comments(first: 50) {\n                                nodes {\n                                    id\n                                    body\n                                    author {\n                                        login\n                                    }\n                                    createdAt\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    `;\n    const result = await executeGraphQL<{\n        repository: {\n            pullRequest: {\n                reviewThreads: {\n                    nodes: Array<{\n                        id: string;\n                        isResolved: boolean;\n                        isOutdated: boolean;\n                        path: string;\n                        line: number | null;\n                        comments: {\n                            nodes: Array<{\n                                id: string;\n                                body: string;\n                                author: { login: string } | null;\n                                createdAt: string;\n                            }>;\n                        };\n                    }>;\n                };\n            };\n        };\n    }>(query, { owner, repo, number: prNumber });\n\n    return result.repository.pullRequest.reviewThreads.nodes.map((thread) => ({\n        id: thread.id,\n        isResolved: thread.isResolved,\n        isOutdated: thread.isOutdated,\n        path: thread.path,\n        line: thread.line,\n        comments: thread.comments.nodes.map((c) => ({\n            id: c.id,\n            body: c.body,\n            author: c.author?.login || 'unknown',\n            createdAt: c.createdAt,\n        })),\n    }));\n}\n\n/**\n * Resolve a review thread\n */\nexport async function resolveReviewThread(threadId: string): Promise<boolean> {\n    const mutation = `\n        mutation ResolveThread($threadId: ID!) {\n            resolveReviewThread(input: { threadId: $threadId }) {\n                thread {\n                    isResolved\n                }\n            }\n        }\n    `;\n    const result = await executeGraphQL<{\n        resolveReviewThread: { thread: { isResolved: boolean } };\n    }>(mutation, { threadId });\n    return result.resolveReviewThread.thread.isResolved;\n}\n\n/**\n * Mark a draft PR as ready for review\n */\nexport async function markPRReadyForReview(prNumber: number): Promise<boolean> {\n    const pullRequestId = await getPRNodeId(prNumber);\n    const mutation = `\n        mutation MarkReadyForReview($pullRequestId: ID!) {\n            markPullRequestReadyForReview(input: { pullRequestId: $pullRequestId }) {\n                pullRequest {\n                    isDraft\n                }\n            }\n        }\n    `;\n    const result = await executeGraphQL<{\n        markPullRequestReadyForReview: { pullRequest: { isDraft: boolean } };\n    }>(mutation, { pullRequestId });\n    return !result.markPullRequestReadyForReview.pullRequest.isDraft;\n}\n"],"mappings":";;;;;;;AAYA,SAAS,gBAAgB;AAIzB,IAAI,gBAAkC;AACtC,IAAI,iBAA4C;AAChD,IAAI,iBAAmC;AACvC,IAAI,kBAA6C;AAKjD,eAAsB,qBAAyC;AAC3D,MAAI,cAAe,QAAO;AAE1B,MAAI,CAAC,gBAAgB;AACjB,qBAAiB,mBAAmB,EAAE,KAAK,CAAC,WAAW;AACnD,sBAAgB;AAChB,aAAO;AAAA,IACX,CAAC;AAAA,EACL;AAEA,SAAO;AACX;AAKA,eAAsB,oBAAmC;AACrD,MAAI,eAAe;AACf,UAAM,cAAc,MAAM;AAC1B,oBAAgB;AAChB,qBAAiB;AAAA,EACrB;AACJ;AAKA,eAAsB,sBAA0C;AAC5D,MAAI,eAAgB,QAAO;AAE3B,MAAI,CAAC,iBAAiB;AAClB,sBAAkB,oBAAoB,EAAE,KAAK,CAAC,WAAW;AACrD,uBAAiB;AACjB,aAAO;AAAA,IACX,CAAC;AAAA,EACL;AAEA,SAAO;AACX;AAKA,eAAsB,qBAAoC;AACtD,MAAI,gBAAgB;AAChB,UAAM,eAAe,MAAM;AAC3B,qBAAiB;AACjB,sBAAkB;AAAA,EACtB;AACJ;AAKA,eAAsB,kBAAiC;AACnD,QAAM,QAAQ,IAAI,CAAC,kBAAkB,GAAG,mBAAmB,CAAC,CAAC;AACjE;AASA,eAAsB,eAA4B,OAAe,WAAiD;AAC9G,QAAM,SAAS,MAAM,oBAAoB;AACzC,QAAM,QAAQ,MAAM,OAAO,MAAM;AAGjC,QAAM,OAAO,MAAM,eAAe,KAAK,MAAM,WAAW,MAAM,WAAW,MAAM;AAC/E,MAAI,CAAC,MAAM;AACP,UAAM,IAAI,MAAM,gDAAgD,OAAO,KAAK,KAAK,EAAE,KAAK,IAAI,CAAC,EAAE;AAAA,EACnG;AAEA,MAAI,OAAO,KAAK,YAAY,YAAY;AACpC,UAAM,IAAI,MAAM,oCAAoC;AAAA,EACxD;AAGA,QAAM,OAA8C,EAAE,MAAM;AAC5D,MAAI,aAAa,OAAO,KAAK,SAAS,EAAE,SAAS,GAAG;AAChD,SAAK,YAAY,KAAK,UAAU,SAAS;AAAA,EAC7C;AAGA,QAAM,SAAS,MAAO,KAAK,QAAgB,IAAI;AAC/C,QAAM,OAAO,qBAAqB,MAAM;AAExC,MAAI,KAAK,UAAU,KAAK,OAAO,SAAS,GAAG;AACvC,UAAM,IAAI,MAAM,kBAAkB,KAAK,OAAO,IAAI,CAAC,MAA2B,EAAE,OAAO,EAAE,KAAK,IAAI,CAAC,EAAE;AAAA,EACzG;AACA,SAAQ,KAAK,QAAQ;AACzB;AAKA,SAAS,qBAAqB,QAAkB;AAE5C,MAAI,OAAO,WAAW,MAAM,QAAQ,OAAO,OAAO,GAAG;AACjD,UAAM,cAAc,OAAO,QAAQ,KAAK,CAAC,MAAwB,EAAE,SAAS,MAAM;AAClF,QAAI,aAAa,MAAM;AACnB,aAAO,KAAK,MAAM,YAAY,IAAI;AAAA,IACtC;AAAA,EACJ;AACA,SAAO;AACX;AAKA,eAAe,eAAe,UAAkB,MAAiD;AAC7F,QAAM,SAAS,MAAM,mBAAmB;AACxC,QAAM,QAAQ,MAAM,OAAO,MAAM;AAEjC,QAAM,OAAO,MAAM,QAAQ;AAC3B,MAAI,CAAC,MAAM;AACP,UAAM,IAAI,MAAM,oBAAoB,QAAQ,aAAa;AAAA,EAC7D;AAIA,MAAI,OAAO,KAAK,YAAY,YAAY;AAEpC,WAAQ,KAAK,QAAgB,IAAI;AAAA,EACrC;AAEA,QAAM,IAAI,MAAM,oBAAoB,QAAQ,qBAAqB;AACrE;AAMO,SAAS,iBAAkD;AAE9D,QAAM,aAAa,QAAQ,IAAI;AAC/B,MAAI,YAAY;AACZ,UAAM,CAAC,OAAO,IAAI,IAAI,WAAW,MAAM,GAAG;AAC1C,WAAO,EAAE,OAAO,KAAK;AAAA,EACzB;AAGA,MAAI;AACA,UAAM,SAAS,SAAS,6BAA6B;AAAA,MACjD,UAAU;AAAA,MACV,OAAO,CAAC,QAAQ,QAAQ,MAAM;AAAA,IAClC,CAAC,EAAE,KAAK;AAKR,UAAM,aAAa,OAAO,MAAM,gCAAgC;AAChE,UAAM,WAAW,OAAO,MAAM,+BAA+B;AAE7D,UAAM,QAAQ,cAAc;AAC5B,QAAI,OAAO;AACP,aAAO,EAAE,OAAO,MAAM,CAAC,GAAG,MAAM,MAAM,CAAC,EAAE;AAAA,IAC7C;AAAA,EACJ,QAAQ;AAAA,EAER;AAEA,QAAM,IAAI;AAAA,IACN;AAAA,EACJ;AACJ;AAGO,SAAS,aAAoB;AAChC,QAAM,IAAI;AAAA,IACN;AAAA,EAIJ;AACJ;AASA,eAAsB,SAClB,aACA,aAOD;AACC,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe,eAAe;AACtD,QAAM,SAAU,MAAM,eAAe,aAAa;AAAA,IAC9C;AAAA,IACA;AAAA,IACA,cAAc;AAAA,EAClB,CAAC;AAQD,SAAO;AAAA,IACH,QAAQ,OAAO;AAAA,IACf,OAAO,OAAO;AAAA,IACd,MAAM,OAAO,QAAQ;AAAA,IACrB,OAAO,OAAO;AAAA,IACd,QAAQ,OAAO,QAAQ,IAAI,CAAC,MAAM,EAAE,IAAI,KAAK,CAAC;AAAA,EAClD;AACJ;AAQA,eAAsB,gBAAgB,aAAqB,MAA6B;AACpF,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe;AACvC,QAAM,eAAe,qBAAqB;AAAA,IACtC;AAAA,IACA;AAAA,IACA,cAAc;AAAA,IACd;AAAA,EACJ,CAAC;AACL;AAKA,eAAsB,mBAAmB,aAAqB,MAA6B;AACvF,SAAO,gBAAgB,aAAa,IAAI;AAC5C;AAKA,eAAsB,YAClB,OAMA,aAC2B;AAC3B,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe,eAAe;AACtD,QAAM,SAAU,MAAM,eAAe,gBAAgB;AAAA,IACjD;AAAA,IACA;AAAA,IACA,GAAG;AAAA,EACP,CAAC;AACD,SAAO,EAAE,QAAQ,OAAO,OAAO;AACnC;AAKA,eAAsB,YAClB,aACA,SAOA,aACa;AACb,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe,eAAe;AACtD,QAAM,eAAe,gBAAgB;AAAA,IACjC;AAAA,IACA;AAAA,IACA,cAAc;AAAA,IACd,GAAG;AAAA,EACP,CAAC;AACL;AAKA,eAAsB,eAAe,aAAqB,QAAiC;AACvF,MAAI,OAAO,WAAW,EAAG;AACzB,QAAM,QAAQ,MAAM,SAAS,WAAW;AACxC,QAAM,SAAS,MAAM,KAAK,oBAAI,IAAI,CAAC,GAAG,MAAM,QAAQ,GAAG,MAAM,CAAC,CAAC;AAC/D,QAAM,YAAY,aAAa,EAAE,QAAQ,OAAO,CAAC;AACrD;AAKA,eAAsB,YAAY,UAAkB,MAA6B;AAC7E,SAAO,gBAAgB,UAAU,IAAI;AACzC;AAQA,eAAsB,aAClB,OACA,aAQF;AAEE,MAAI;AACA,WAAO,MAAM,oBAAoB,OAAO,CAAC,GAAG,WAAW;AAAA,EAC3D,SAAS,OAAO;AAEZ,YAAQ,KAAK,2DAA2D,KAAK;AAAA,EACjF;AAEA,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe,eAAe;AACtD,QAAM,YAAY,QAAQ,KAAK,IAAI,IAAI,IAAI,KAAK;AAEhD,QAAM,SAAU,MAAM,eAAe,iBAAiB;AAAA,IAClD,OAAO;AAAA,EACX,CAAC;AASD,UAAQ,OAAO,SAAS,CAAC,GAAG,IAAI,CAAC,UAAU;AAAA,IACvC,QAAQ,KAAK;AAAA,IACb,OAAO,KAAK;AAAA,IACZ,OAAO,KAAK;AAAA,IACZ,QAAQ,KAAK,QAAQ,IAAI,CAAC,MAAM,EAAE,IAAI,KAAK,CAAC;AAAA,EAChD,EAAE;AACN;AAOA,eAAsB,oBAClB,OACA,UAAqD,CAAC,GACtD,aASF;AACE,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe,eAAe;AACtD,QAAM,EAAE,QAAQ,KAAK,cAAc,MAAM,IAAI;AAG7C,QAAM,SAAS,MAAM,SAAS,SAAS,KAAK,MAAM,SAAS,YAAY;AACvE,QAAM,WAAW,MAAM,SAAS,WAAW,KAAK,MAAM,SAAS,cAAc;AAC7E,QAAM,SAAS,WAAW,WAAW,SAAS,SAAS;AAGvD,QAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoBjB,QAAM,YAAqC,EAAE,OAAO,MAAM,OAAO,YAAY;AAC7E,MAAI,QAAQ;AACR,cAAU,SAAS,CAAC,MAAM;AAAA,EAC9B;AAEA,QAAM,SAAS,MAAM,eAYlB,UAAU,SAAS;AAEtB,SAAO,OAAO,WAAW,OAAO,MAAM,IAAI,CAAC,WAAW;AAAA,IAClD,QAAQ,MAAM;AAAA,IACd,OAAO,MAAM;AAAA,IACb,OAAO,MAAM,MAAM,YAAY;AAAA,IAC/B,QAAQ,MAAM,OAAO,MAAM,IAAI,CAAC,MAAM,EAAE,IAAI;AAAA,IAC5C,GAAI,eAAe,EAAE,MAAM,MAAM,KAAK;AAAA,EAC1C,EAAE;AACN;AAKA,eAAsB,eAAe,UASlC;AACC,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe;AACvC,QAAM,SAAU,MAAM,eAAe,oBAAoB;AAAA,IACrD;AAAA,IACA;AAAA,IACA,aAAa;AAAA,EACjB,CAAC;AAWD,SAAO;AACX;AAKA,eAAsB,YAClB,QACA,UAAiC,CAAC,GAOpC;AACE,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe;AACvC,QAAM,SAAU,MAAM,eAAe,gBAAgB;AAAA,IACjD;AAAA,IACA;AAAA,IACA,KAAK;AAAA,IACL,UAAU,QAAQ,YAAY;AAAA,EAClC,CAAC;AAMD,SAAO,OAAO,IAAI,CAAC,OAAO;AAAA,IACtB,KAAK,EAAE;AAAA,IACP,SAAS,EAAE,OAAO;AAAA,IAClB,QAAQ,EAAE,QAAQ,SAAS;AAAA,EAC/B,EAAE;AACN;AAKA,eAAsB,gBAAgB,MAAc,UAA4B,CAAC,GAAoB;AACjG,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe;AACvC,QAAM,SAAU,MAAM,eAAe,qBAAqB;AAAA,IACtD;AAAA,IACA;AAAA,IACA;AAAA,IACA,KAAK,QAAQ;AAAA,EACjB,CAAC;AAED,MAAI,OAAO,WAAW,OAAO,aAAa,UAAU;AAChD,WAAO,OAAO,KAAK,OAAO,SAAS,QAAQ,EAAE,SAAS,OAAO;AAAA,EACjE;AAEA,SAAO,OAAO,WAAW;AAC7B;AA0EA,eAAe,YAAY,UAAmC;AAC1D,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe;AACvC,QAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASd,QAAM,SAAS,MAAM,eAElB,OAAO,EAAE,OAAO,MAAM,QAAQ,SAAS,CAAC;AAC3C,SAAO,OAAO,WAAW,YAAY;AACzC;AAKA,eAAsB,iBAAiB,UAAiC;AACpE,QAAM,gBAAgB,MAAM,YAAY,QAAQ;AAChD,QAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASjB,QAAM,eAAe,UAAU,EAAE,cAAc,CAAC;AACpD;AAKA,eAAsB,gBAClB,UACA,cAA6C,UAChC;AACb,QAAM,gBAAgB,MAAM,YAAY,QAAQ;AAChD,QAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWjB,QAAM,eAAe,UAAU,EAAE,eAAe,YAAY,CAAC;AACjE;AAKA,eAAsB,iBAAiB,UAAiC;AACpE,QAAM,gBAAgB,MAAM,YAAY,QAAQ;AAChD,QAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWjB,QAAM,eAAe,UAAU,EAAE,cAAc,CAAC;AACpD;AAKA,eAAsB,oBAAoB,UAA4C;AAClF,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe;AACvC,QAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA0Bd,QAAM,SAAS,MAAM,eAqBlB,OAAO,EAAE,OAAO,MAAM,QAAQ,SAAS,CAAC;AAE3C,QAAM,WAA4B,CAAC;AACnC,aAAW,UAAU,OAAO,WAAW,YAAY,cAAc,OAAO;AACpE,eAAW,KAAK,OAAO,SAAS,OAAO;AACnC,eAAS,KAAK;AAAA,QACV,IAAI,EAAE;AAAA,QACN,QAAQ,EAAE;AAAA,QACV,MAAM,EAAE;AAAA,QACR,MAAM,OAAO;AAAA,QACb,MAAM,OAAO,QAAQ;AAAA,QACrB,MAAM,EAAE,QAAQ,SAAS;AAAA,QACzB,WAAW,EAAE;AAAA,QACb,OAAO,EAAE;AAAA,MACb,CAAC;AAAA,IACL;AAAA,EACJ;AACA,SAAO;AACX;AAKA,eAAsB,aAAa,UAQjC;AACE,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe;AACvC,QAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBd,QAAM,SAAS,MAAM,eAclB,OAAO,EAAE,OAAO,MAAM,QAAQ,SAAS,CAAC;AAE3C,SAAO,OAAO,WAAW,YAAY,QAAQ,MAAM,IAAI,CAAC,OAAO;AAAA,IAC3D,IAAI,EAAE;AAAA,IACN,MAAM,EAAE,QAAQ,SAAS;AAAA,IACzB,OAAO,EAAE;AAAA,IACT,MAAM,EAAE,QAAQ;AAAA,IAChB,aAAa,EAAE;AAAA,EACnB,EAAE;AACN;AASA,eAAsB,qBAAqB,UAAkB,eAAuB,MAA6B;AAC7G,QAAM,gBAAgB,MAAM,YAAY,QAAQ;AAChD,QAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAajB,QAAM,eAAe,UAAU;AAAA,IAC3B;AAAA,IACA;AAAA,IACA,WAAW;AAAA,EACf,CAAC;AACL;AAKA,eAAsB,eAClB,UACA,OACA,MACa;AACb,QAAM,gBAAgB,MAAM,YAAY,QAAQ;AAChD,QAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAcjB,QAAM,eAAe,UAAU,EAAE,eAAe,OAAO,KAAK,CAAC;AACjE;AAKA,eAAsB,aAAa,KAAkC;AACjE,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe;AACvC,QAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyBd,QAAM,SAAS,MAAM,eAoBlB,OAAO,EAAE,OAAO,MAAM,IAAI,CAAC;AAE9B,QAAM,YAAwB,CAAC;AAC/B,aAAW,SAAS,OAAO,WAAW,QAAQ,aAAa,SAAS,CAAC,GAAG;AACpE,eAAW,OAAO,MAAM,UAAU,OAAO;AACrC,gBAAU,KAAK;AAAA,QACX,IAAI,IAAI;AAAA,QACR,MAAM,IAAI;AAAA,QACV,QAAQ,IAAI;AAAA,QACZ,YAAY,IAAI;AAAA,QAChB,WAAW,IAAI;AAAA,QACf,aAAa,IAAI;AAAA,QACjB,KAAK,IAAI;AAAA,MACb,CAAC;AAAA,IACL;AAAA,EACJ;AACA,SAAO;AACX;AAKA,eAAsB,oBAAoB,KAIvC;AACC,QAAM,SAAS,MAAM,aAAa,GAAG;AAErC,QAAM,UAAU,OAAO,OAAO,CAAC,MAAM,EAAE,WAAW,WAAW,EAAE;AAE/D,QAAM,SAAS,OACV,OAAO,CAAC,MAAM,EAAE,eAAe,aAAa,EAAE,eAAe,eAAe,EAAE,eAAe,WAAW,EACxG,IAAI,CAAC,MAAM,EAAE,IAAI;AAEtB,QAAM,UAAU,OAAO,WAAW,KAAK,YAAY;AAEnD,SAAO,EAAE,SAAS,SAAS,OAAO;AACtC;AAEA,eAAsB,eAClB,OACA,UACA,UAOe;AACf,QAAM,IAAI,MAAM,+DAA+D;AACnF;AAEA,eAAsB,sBAAsB,QAAuE;AAC/G,QAAM,IAAI,MAAM,sEAAsE;AAC1F;AAEA,eAAsB,wBAAwB,WAAiD;AAC3F,QAAM,IAAI,MAAM,wEAAwE;AAC5F;AAEA,eAAsB,oBAAoB,QAAqE;AAC3G,QAAM,IAAI,MAAM,oEAAoE;AACxF;AAKA,eAAsB,cAClB,KACA,SAC+C;AAC/C,QAAM,UAAU,SAAS,WAAW;AACpC,QAAM,eAAe,SAAS,gBAAgB;AAC9C,QAAM,YAAY,KAAK,IAAI;AAE3B,SAAO,KAAK,IAAI,IAAI,YAAY,SAAS;AACrC,UAAM,SAAS,MAAM,oBAAoB,GAAG;AAE5C,QAAI,OAAO,YAAY,GAAG;AACtB,aAAO,EAAE,SAAS,OAAO,SAAS,QAAQ,OAAO,OAAO;AAAA,IAC5D;AAGA,UAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,YAAY,CAAC;AAAA,EACpE;AAGA,QAAM,cAAc,MAAM,oBAAoB,GAAG;AACjD,SAAO,EAAE,SAAS,OAAO,QAAQ,CAAC,GAAG,YAAY,QAAQ,SAAS,EAAE;AACxE;AAEO,SAAS,kBAAkB,cAAmC,YAAuC;AACxG,QAAM,QAAkB,CAAC;AAEzB,MAAI,aAAa,SAAS,GAAG;AACzB,UAAM,KAAK,yBAAyB;AACpC,eAAW,SAAS,cAAc;AAC9B,YAAM,KAAK,OAAO,MAAM,KAAK,EAAE,OAAO,MAAM,KAAK,QAAQ,MAAM,MAAM,KAAK,WAAW,EAAE;AACvF,UAAI,MAAM,UAAU;AAChB,cAAM,KAAK,iBAAiB,MAAM,SAAS,IAAI,IAAI,MAAM,SAAS,SAAS,EAAE;AAAA,MACjF;AAAA,IACJ;AACA,UAAM,KAAK,EAAE;AAAA,EACjB;AAEA,MAAI,WAAW,SAAS,GAAG;AACvB,UAAM,KAAK,sBAAsB;AACjC,eAAW,SAAS,YAAY;AAC5B,YAAM,KAAK,OAAO,MAAM,WAAW,OAAO,OAAO,MAAM,sBAAsB,QAAQ,GAAG;AACxF,YAAM,KAAK,OAAO,MAAM,iBAAiB,OAAO,EAAE;AAClD,UAAI,MAAM,sBAAsB,qBAAqB;AACjD,cAAM,KAAK,uBAAuB,MAAM,sBAAsB,mBAAmB,EAAE;AAAA,MACvF;AAAA,IACJ;AACA,UAAM,KAAK,EAAE;AAAA,EACjB;AAEA,SAAO,MAAM,KAAK,IAAI;AAC1B;AAKA,eAAsB,mBAAmB,UAA2C;AAChF,QAAM,EAAE,OAAO,KAAK,IAAI,eAAe;AACvC,QAAM,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA2Bd,QAAM,SAAS,MAAM,eAsBlB,OAAO,EAAE,OAAO,MAAM,QAAQ,SAAS,CAAC;AAE3C,SAAO,OAAO,WAAW,YAAY,cAAc,MAAM,IAAI,CAAC,YAAY;AAAA,IACtE,IAAI,OAAO;AAAA,IACX,YAAY,OAAO;AAAA,IACnB,YAAY,OAAO;AAAA,IACnB,MAAM,OAAO;AAAA,IACb,MAAM,OAAO;AAAA,IACb,UAAU,OAAO,SAAS,MAAM,IAAI,CAAC,OAAO;AAAA,MACxC,IAAI,EAAE;AAAA,MACN,MAAM,EAAE;AAAA,MACR,QAAQ,EAAE,QAAQ,SAAS;AAAA,MAC3B,WAAW,EAAE;AAAA,IACjB,EAAE;AAAA,EACN,EAAE;AACN;AAKA,eAAsB,oBAAoB,UAAoC;AAC1E,QAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASjB,QAAM,SAAS,MAAM,eAElB,UAAU,EAAE,SAAS,CAAC;AACzB,SAAO,OAAO,oBAAoB,OAAO;AAC7C;AAKA,eAAsB,qBAAqB,UAAoC;AAC3E,QAAM,gBAAgB,MAAM,YAAY,QAAQ;AAChD,QAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASjB,QAAM,SAAS,MAAM,eAElB,UAAU,EAAE,cAAc,CAAC;AAC9B,SAAO,CAAC,OAAO,8BAA8B,YAAY;AAC7D;","names":[]}