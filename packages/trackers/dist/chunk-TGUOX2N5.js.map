{"version":3,"sources":["../src/mcp.ts"],"sourcesContent":["/**\n * MCP (Model Context Protocol) Integration\n *\n * This module provides unified access to all MCP servers used by triage:\n *\n * | Server         | Purpose                                              |\n * |----------------|------------------------------------------------------|\n * | **Filesystem** | Read/write files - CRITICAL for Ollama's limited context |\n * | **GitHub**     | Issues, PRs, projects, commits - full GitHub API    |\n * | **Playwright** | Browser automation, E2E testing, visual verification |\n * | **Context7**   | Library documentation lookup - PREVENTS HALLUCINATIONS |\n * | **Vite React** | React component debugging, state inspection, render tracking |\n *\n * ## Key Design Principles\n *\n * 1. **Ollama has LIMITED context** - The AI MUST use filesystem tools to read\n *    file contents and write changes directly. We cannot fit entire codebases\n *    in the prompt.\n *\n * 2. **Context7 prevents hallucinations** - Instead of guessing API details,\n *    the AI can look up actual library documentation.\n *\n * 3. **Vite React MCP** - For debugging React apps during development/testing,\n *    can inspect component tree, props, state, and track unnecessary re-renders.\n *\n * 4. **GitHub MCP** - Full API access for issues, PRs, projects without\n *    needing to shell out to `gh` CLI.\n */\n\nimport { experimental_createMCPClient as createMCPClient } from '@ai-sdk/mcp';\nimport { Experimental_StdioMCPTransport as StdioMCPTransport } from '@ai-sdk/mcp/mcp-stdio';\nimport { generateText, stepCountIs } from 'ai';\nimport { resolveModel, type ToolSet } from '@agentic/triage-ai';\n\nexport type MCPClient = Awaited<ReturnType<typeof createMCPClient>>;\n\n// =============================================================================\n// FILESYSTEM MCP\n// =============================================================================\n\n/**\n * Create Filesystem MCP client for file operations\n *\n * Uses an inline server for reliability (no npx dependency).\n * This is the MOST IMPORTANT MCP - it lets the AI read and write files\n * since Ollama can't fit everything in context.\n */\nexport async function createFilesystemClient(workingDirectory: string): Promise<MCPClient> {\n    return createInlineFilesystemClient(workingDirectory);\n}\n\n/**\n * Inline filesystem MCP server\n *\n * Provides: read_file, write_file, list_files, search_files\n * All paths are sandboxed to workingDirectory for security.\n */\nexport async function createInlineFilesystemClient(workingDirectory: string): Promise<MCPClient> {\n    const fs = await import('node:fs/promises');\n    const path = await import('node:path');\n    const os = await import('node:os');\n\n    const serverCode = `\nconst fs = require('fs').promises;\nconst path = require('path');\nconst readline = require('readline');\n\nconst BASE_DIR = ${JSON.stringify(workingDirectory)};\n\nfunction resolvePath(relativePath) {\n    const resolved = path.resolve(BASE_DIR, relativePath);\n    if (!resolved.startsWith(BASE_DIR)) {\n        throw new Error('Path traversal not allowed');\n    }\n    return resolved;\n}\n\nconst tools = {\n    read_file: {\n        name: 'read_file',\n        description: 'Read the contents of a file. Use this to examine source code, configs, or any text file. ESSENTIAL - use this instead of guessing file contents!',\n        inputSchema: {\n            type: 'object',\n            properties: {\n                path: { type: 'string', description: 'Path to the file relative to workspace root' }\n            },\n            required: ['path']\n        }\n    },\n    write_file: {\n        name: 'write_file',\n        description: 'Write content to a file. Creates parent directories if needed. Use this to make actual code changes!',\n        inputSchema: {\n            type: 'object',\n            properties: {\n                path: { type: 'string', description: 'Path to the file relative to workspace root' },\n                content: { type: 'string', description: 'Complete content to write to the file' }\n            },\n            required: ['path', 'content']\n        }\n    },\n    list_files: {\n        name: 'list_files',\n        description: 'List files and directories in a path. Use to explore project structure.',\n        inputSchema: {\n            type: 'object',\n            properties: {\n                path: { type: 'string', description: 'Directory path relative to workspace root', default: '.' }\n            }\n        }\n    },\n    search_files: {\n        name: 'search_files',\n        description: 'Search for files matching a glob pattern. Use to find relevant files quickly.',\n        inputSchema: {\n            type: 'object',\n            properties: {\n                pattern: { type: 'string', description: 'Glob pattern like *.ts or **/*.test.ts' },\n                path: { type: 'string', description: 'Directory to search in', default: '.' }\n            },\n            required: ['pattern']\n        }\n    }\n};\n\nconst rl = readline.createInterface({ input: process.stdin, output: process.stdout });\n\nrl.on('line', async (input) => {\n    try {\n        const request = JSON.parse(input);\n\n        if (request.method === 'initialize') {\n            console.log(JSON.stringify({\n                jsonrpc: '2.0',\n                id: request.id,\n                result: {\n                    protocolVersion: '2024-11-05',\n                    capabilities: { tools: {} },\n                    serverInfo: { name: 'strata-filesystem', version: '1.0.0' }\n                }\n            }));\n            return;\n        }\n\n        if (request.method === 'notifications/initialized') return;\n\n        if (request.method === 'tools/list') {\n            console.log(JSON.stringify({\n                jsonrpc: '2.0',\n                id: request.id,\n                result: { tools: Object.values(tools) }\n            }));\n            return;\n        }\n\n        if (request.method === 'tools/call') {\n            const { name, arguments: args } = request.params;\n            let result;\n\n            try {\n                switch (name) {\n                    case 'read_file': {\n                        const filePath = resolvePath(args.path);\n                        const content = await fs.readFile(filePath, 'utf-8');\n                        result = { content, path: args.path, lines: content.split('\\\\n').length };\n                        break;\n                    }\n                    case 'write_file': {\n                        const filePath = resolvePath(args.path);\n                        await fs.mkdir(path.dirname(filePath), { recursive: true });\n                        await fs.writeFile(filePath, args.content, 'utf-8');\n                        result = { success: true, path: args.path, bytesWritten: args.content.length };\n                        break;\n                    }\n                    case 'list_files': {\n                        const dirPath = resolvePath(args.path || '.');\n                        const entries = await fs.readdir(dirPath, { withFileTypes: true });\n                        result = {\n                            path: args.path || '.',\n                            entries: entries.map(e => ({\n                                name: e.name,\n                                type: e.isDirectory() ? 'directory' : 'file'\n                            }))\n                        };\n                        break;\n                    }\n                    case 'search_files': {\n                        const searchDir = resolvePath(args.path || '.');\n                        const pattern = args.pattern.replace(/\\\\*/g, '.*').replace(/\\\\?/g, '.');\n                        const regex = new RegExp(pattern);\n                        const matches = [];\n\n                        async function walk(dir, depth = 0) {\n                            if (depth > 10) return;\n                            try {\n                                const entries = await fs.readdir(dir, { withFileTypes: true });\n                                for (const entry of entries) {\n                                    const fullPath = path.join(dir, entry.name);\n                                    const relativePath = path.relative(BASE_DIR, fullPath);\n                                    if (entry.isDirectory()) {\n                                        if (!entry.name.startsWith('.') && entry.name !== 'node_modules') {\n                                            await walk(fullPath, depth + 1);\n                                        }\n                                    } else if (regex.test(entry.name) || regex.test(relativePath)) {\n                                        matches.push(relativePath);\n                                    }\n                                }\n                            } catch (e) { /* ignore */ }\n                        }\n                        await walk(searchDir);\n                        result = { pattern: args.pattern, matches: matches.slice(0, 100) };\n                        break;\n                    }\n                    default:\n                        result = { error: 'Unknown tool: ' + name };\n                }\n            } catch (err) {\n                result = { error: err.message };\n            }\n\n            console.log(JSON.stringify({\n                jsonrpc: '2.0',\n                id: request.id,\n                result: { content: [{ type: 'text', text: JSON.stringify(result, null, 2) }] }\n            }));\n        }\n    } catch (err) {\n        console.log(JSON.stringify({\n            jsonrpc: '2.0',\n            id: null,\n            error: { code: -1, message: err.message }\n        }));\n    }\n});\n`;\n\n    const serverPath = path.join(os.tmpdir(), `strata-fs-mcp-${Date.now()}.cjs`);\n    await fs.writeFile(serverPath, serverCode);\n\n    const transport = new StdioMCPTransport({\n        command: 'node',\n        args: [serverPath],\n        cwd: workingDirectory,\n    });\n\n    return createMCPClient({ transport });\n}\n\n/**\n * Get filesystem tools from client\n */\nexport async function getFilesystemTools(client: MCPClient): Promise<ToolSet> {\n    return client.tools();\n}\n\n// =============================================================================\n// GITHUB MCP\n// =============================================================================\n\n/**\n * Create GitHub MCP client for issue/PR/project operations\n *\n * Provides access to:\n * - create_issue, update_issue, get_issue\n * - create_pull_request, merge_pull_request\n * - add_label, remove_label\n * - get_file_contents, create_or_update_file\n * - search_issues, search_repositories\n */\nexport async function createGitHubClient(): Promise<MCPClient> {\n    const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;\n    if (!token) {\n        throw new Error('GITHUB_TOKEN or GH_TOKEN required for GitHub MCP');\n    }\n\n    const transport = new StdioMCPTransport({\n        command: 'npx',\n        args: ['-y', '@modelcontextprotocol/server-github'],\n        env: {\n            ...process.env,\n            GITHUB_PERSONAL_ACCESS_TOKEN: token,\n        },\n    });\n\n    return createMCPClient({ transport });\n}\n\n/**\n * Get GitHub tools from client\n */\nexport async function getGitHubTools(client: MCPClient): Promise<ToolSet> {\n    return client.tools();\n}\n\n// =============================================================================\n// PLAYWRIGHT MCP\n// =============================================================================\n\n/**\n * Create Playwright MCP client for browser automation\n *\n * Used for E2E testing, visual verification, and user flow testing.\n *\n * Provides:\n * - browser_navigate, browser_click, browser_type\n * - browser_snapshot, browser_take_screenshot\n * - browser_verify_* (with testing capabilities)\n */\nexport async function createPlaywrightClient(\n    options: {\n        headless?: boolean;\n        browser?: 'chromium' | 'firefox' | 'webkit';\n        outputDir?: string;\n        testingCapabilities?: boolean;\n    } = {}\n): Promise<MCPClient> {\n    const { headless = true, browser = 'chromium', outputDir = './test-output', testingCapabilities = true } = options;\n\n    const args = ['-y', '@playwright/mcp@latest'];\n\n    if (headless) args.push('--headless');\n    args.push('--browser', browser);\n    args.push('--output-dir', outputDir);\n    if (testingCapabilities) args.push('--caps=testing');\n\n    const transport = new StdioMCPTransport({\n        command: 'npx',\n        args,\n    });\n\n    return createMCPClient({ transport });\n}\n\n/**\n * Get Playwright tools from client\n */\nexport async function getPlaywrightTools(client: MCPClient): Promise<ToolSet> {\n    return client.tools();\n}\n\n// =============================================================================\n// CONTEXT7 MCP - DOCUMENTATION LOOKUP (PREVENTS HALLUCINATIONS!)\n// =============================================================================\n\n/**\n * Create Context7 MCP client for library documentation lookup\n *\n * CRITICAL for preventing hallucinations!\n * Provides access to up-to-date library documentation so the AI can\n * reference-check instead of making up API details.\n *\n * Tools provided:\n * - resolve-library-id: Find Context7 library ID from name\n * - get-library-docs: Get documentation for a library\n *\n * Uses HTTP transport to Context7's cloud service.\n * Requires CONTEXT7_API_KEY environment variable.\n */\nexport async function createContext7Client(): Promise<MCPClient> {\n    const apiKey = process.env.CONTEXT7_API_KEY;\n\n    // Use HTTP transport to Context7's cloud service\n    const client = await createMCPClient({\n        transport: {\n            type: 'http',\n            url: 'https://mcp.context7.com/mcp',\n            headers: apiKey ? { CONTEXT7_API_KEY: apiKey } : undefined,\n        },\n    });\n\n    return client;\n}\n\n/**\n * Get Context7 tools from client\n *\n * Available tools:\n * - resolve-library-id: Resolve library name to Context7 ID\n * - get-library-docs: Get library documentation\n */\nexport async function getContext7Tools(client: MCPClient): Promise<ToolSet> {\n    return client.tools();\n}\n\n// =============================================================================\n// VITE REACT MCP - REACT COMPONENT DEBUGGING\n// =============================================================================\n\n/**\n * Create Vite React MCP client for React component debugging\n *\n * Connects to a running Vite dev server with the vite-react-mcp plugin.\n * Used for debugging React apps during development and testing.\n *\n * Tools provided:\n * - highlight-component: Highlight a React component by name\n * - get-component-states: Get props, states, and contexts\n * - get-component-tree: Get component tree in ASCII format\n * - get-unnecessary-rerenders: Track wasted renders\n *\n * Requires the app to be running with vite-react-mcp plugin installed.\n */\nexport async function createViteReactClient(\n    options: {\n        /** URL of the Vite dev server SSE endpoint (default: http://localhost:5173/sse) */\n        url?: string;\n        /** Port number (alternative to full URL) */\n        port?: number;\n    } = {}\n): Promise<MCPClient> {\n    const { port = 5173 } = options;\n    const url = options.url || `http://localhost:${port}/sse`;\n\n    const client = await createMCPClient({\n        transport: {\n            type: 'sse',\n            url,\n        },\n    });\n\n    return client;\n}\n\n/**\n * Get Vite React tools from client\n */\nexport async function getViteReactTools(client: MCPClient): Promise<ToolSet> {\n    return client.tools();\n}\n\n// =============================================================================\n// GRAPHQL MCP\n// =============================================================================\n\n/**\n * Create GraphQL MCP client for GitHub GraphQL API operations\n *\n * Uses mcp-graphql to execute GraphQL queries/mutations against GitHub's API.\n * Required for: Projects V2, review threads, draft PR conversion, auto-merge, etc.\n */\nexport async function createGraphQLClient(): Promise<MCPClient> {\n    const token = process.env.GITHUB_TOKEN || process.env.GH_TOKEN;\n    if (!token) {\n        throw new Error('GITHUB_TOKEN or GH_TOKEN required for GraphQL MCP');\n    }\n\n    // mcp-graphql v1.0.0+ uses environment variables instead of CLI args\n    const transport = new StdioMCPTransport({\n        command: 'npx',\n        args: ['-y', 'mcp-graphql'],\n        env: {\n            ...process.env,\n            ENDPOINT: 'https://api.github.com/graphql',\n            HEADERS: JSON.stringify({\n                Authorization: `Bearer ${token}`,\n            }),\n        },\n    });\n\n    return createMCPClient({\n        transport,\n    });\n}\n\n/**\n * Get GraphQL tools from client\n */\nexport async function getGraphQLTools(client: MCPClient): Promise<ToolSet> {\n    return client.tools();\n}\n\n// =============================================================================\n// UNIFIED MCP ACCESS\n// =============================================================================\n\nexport interface MCPClients {\n    filesystem?: MCPClient;\n    github?: MCPClient;\n    playwright?: MCPClient;\n    context7?: MCPClient;\n    viteReact?: MCPClient;\n    graphql?: MCPClient;\n}\n\nexport interface MCPClientOptions {\n    /** Enable filesystem access (required for most tasks) */\n    filesystem?: boolean | string; // string = custom working directory\n\n    /** Enable GitHub API access */\n    github?: boolean;\n\n    /** Enable Playwright browser automation */\n    playwright?:\n        | boolean\n        | {\n              headless?: boolean;\n              browser?: 'chromium' | 'firefox' | 'webkit';\n          };\n\n    /** Enable Context7 documentation lookup (PREVENTS HALLUCINATIONS!) */\n    context7?: boolean;\n\n    /** Enable Vite React component debugging */\n    viteReact?:\n        | boolean\n        | {\n              url?: string;\n              port?: number;\n          };\n\n    /** Enable GitHub GraphQL API access via mcp-graphql */\n    graphql?: boolean;\n}\n\n/**\n * Initialize multiple MCP clients based on options\n *\n * @example\n * const clients = await initializeMCPClients({\n *     filesystem: process.cwd(),  // Required for file access\n *     context7: true,             // Documentation lookup - prevents hallucinations\n *     github: true,               // Issue/PR operations\n * });\n */\nexport async function initializeMCPClients(options: MCPClientOptions): Promise<MCPClients> {\n    const clients: MCPClients = {};\n    const initPromises: Promise<void>[] = [];\n\n    if (options.filesystem) {\n        const dir = typeof options.filesystem === 'string' ? options.filesystem : process.cwd();\n        initPromises.push(\n            createFilesystemClient(dir)\n                .then((client) => {\n                    clients.filesystem = client;\n                })\n                .catch((err) => console.warn('⚠️ Filesystem MCP unavailable:', err.message))\n        );\n    }\n\n    if (options.github) {\n        initPromises.push(\n            createGitHubClient()\n                .then((client) => {\n                    clients.github = client;\n                })\n                .catch((err) => console.warn('⚠️ GitHub MCP unavailable:', err.message))\n        );\n    }\n\n    if (options.playwright) {\n        const playwrightOpts = typeof options.playwright === 'object' ? options.playwright : {};\n        initPromises.push(\n            createPlaywrightClient(playwrightOpts)\n                .then((client) => {\n                    clients.playwright = client;\n                })\n                .catch((err) => console.warn('⚠️ Playwright MCP unavailable:', err.message))\n        );\n    }\n\n    if (options.context7) {\n        initPromises.push(\n            createContext7Client()\n                .then((client) => {\n                    clients.context7 = client;\n                })\n                .catch((err) => console.warn('⚠️ Context7 MCP unavailable:', err.message))\n        );\n    }\n\n    if (options.viteReact) {\n        const viteOpts = typeof options.viteReact === 'object' ? options.viteReact : {};\n        initPromises.push(\n            createViteReactClient(viteOpts)\n                .then((client) => {\n                    clients.viteReact = client;\n                })\n                .catch((err) => console.warn('⚠️ Vite React MCP unavailable:', err.message))\n        );\n    }\n\n    if (options.graphql) {\n        initPromises.push(\n            createGraphQLClient()\n                .then((client) => {\n                    clients.graphql = client;\n                })\n                .catch((err) => console.warn('⚠️ GraphQL MCP unavailable:', err.message))\n        );\n    }\n\n    await Promise.all(initPromises);\n    return clients;\n}\n\n/**\n * Get combined tools from all active MCP clients\n *\n * Tools are available without prefixes for simpler prompts.\n */\nexport async function getAllTools(clients: MCPClients): Promise<ToolSet> {\n    const allTools: ToolSet = {};\n    const toolPromises: Promise<void>[] = [];\n\n    for (const [name, client] of Object.entries(clients)) {\n        if (client) {\n            toolPromises.push(\n                client\n                    .tools()\n                    .then((tools: ToolSet) => {\n                        Object.assign(allTools, tools);\n                    })\n                    .catch((err: Error) => console.warn(`⚠️ Failed to get tools from ${name}:`, err.message))\n            );\n        }\n    }\n\n    await Promise.all(toolPromises);\n    return allTools;\n}\n\n/**\n * Close all MCP clients - ALWAYS call this when done!\n */\nexport async function closeMCPClients(clients: MCPClients): Promise<void> {\n    const closePromises: Promise<void>[] = [];\n\n    for (const client of Object.values(clients)) {\n        if (client) {\n            closePromises.push(\n                client.close().catch(() => {\n                    // Ignore errors during close\n                })\n            );\n        }\n    }\n\n    await Promise.all(closePromises);\n}\n\n// =============================================================================\n// AGENTIC TASK EXECUTION\n// =============================================================================\n\nexport interface AgenticTaskOptions {\n    /** System prompt defining the AI's role and behavior */\n    systemPrompt: string;\n    /** User prompt with the actual task */\n    userPrompt: string;\n    /** MCP clients to enable */\n    mcpClients?: MCPClientOptions;\n    /** Maximum steps for the agentic loop (default: 15) */\n    maxSteps?: number;\n    /** Callback for each tool call */\n    onToolCall?: (toolName: string, args: unknown) => void;\n    /** Callback for each step completion */\n    onStepFinish?: (step: { text?: string; toolCalls?: unknown[] }) => void;\n}\n\nexport interface AgenticTaskResult {\n    /** Final text response from the AI */\n    text: string;\n    /** Total number of tool calls made */\n    toolCallCount: number;\n    /** All steps in the agentic loop */\n    steps: unknown[];\n    /** Reason the loop finished */\n    finishReason: string;\n}\n\n/**\n * Run an agentic task with MCP tools\n *\n * This is the main entry point for AI tasks that need tool access.\n * Properly handles the agentic loop via AI SDK's stopWhen.\n *\n * @example\n * const result = await runAgenticTask({\n *     systemPrompt: 'You are a code reviewer...',\n *     userPrompt: 'Review this PR diff...',\n *     mcpClients: {\n *         filesystem: process.cwd(),  // Read files for context\n *         context7: true,              // Check documentation - prevents hallucinations\n *     },\n *     maxSteps: 15,\n *     onToolCall: (name, args) => console.log(`Using ${name}`),\n * });\n */\nexport async function runAgenticTask(options: AgenticTaskOptions): Promise<AgenticTaskResult> {\n    const {\n        systemPrompt,\n        userPrompt,\n        mcpClients: clientOptions = { filesystem: true },\n        maxSteps = 15,\n        onToolCall,\n        onStepFinish,\n    } = options;\n\n    // Initialize MCP clients\n    const clients = await initializeMCPClients(clientOptions);\n\n    try {\n        // Get all tools from all clients\n        const tools = await getAllTools(clients);\n\n        if (Object.keys(tools).length === 0) {\n            throw new Error('No MCP tools available - check MCP server connections');\n        }\n\n        const resolved = await resolveModel();\n\n        // Run the AI with multi-step tool support\n        const result = await generateText({\n            model: resolved.model,\n            system: systemPrompt,\n            prompt: userPrompt,\n            tools,\n            stopWhen: stepCountIs(maxSteps),\n            onStepFinish: (step) => {\n                // Track tool calls\n                if (step.toolCalls && onToolCall) {\n                    for (const call of step.toolCalls) {\n                        // The Vercel AI SDK's ToolCall type uses a generic for the tool name\n                        // and arguments, but MCP tools have dynamic tool names that can't be\n                        // known at compile time. We cast to any to access toolName/input/args\n                        // properties that exist at runtime but aren't in the generic type.\n                        const tc = call as any;\n                        onToolCall(tc.toolName, tc.input || tc.args);\n                    }\n                }\n\n                // User callback\n                onStepFinish?.({\n                    text: step.text,\n                    toolCalls: step.toolCalls as unknown[],\n                });\n            },\n        });\n\n        // Count total tool calls across all steps\n        const toolCallCount = result.steps?.reduce((acc, step) => acc + (step.toolCalls?.length || 0), 0) || 0;\n\n        return {\n            text: result.text,\n            toolCallCount,\n            steps: result.steps || [],\n            finishReason: result.finishReason,\n        };\n    } finally {\n        // ALWAYS close clients\n        await closeMCPClients(clients);\n    }\n}\n\n// =============================================================================\n// EXPORTED CONSTANTS\n// =============================================================================\n\n/**\n * Playwright tool names for reference\n */\nexport const PLAYWRIGHT_TOOLS = {\n    NAVIGATE: 'browser_navigate',\n    CLICK: 'browser_click',\n    TYPE: 'browser_type',\n    SNAPSHOT: 'browser_snapshot',\n    SCREENSHOT: 'browser_take_screenshot',\n    CLOSE: 'browser_close',\n    WAIT: 'browser_wait_for',\n    EVALUATE: 'browser_evaluate',\n    VERIFY_ELEMENT_VISIBLE: 'browser_verify_element_visible',\n    VERIFY_TEXT_VISIBLE: 'browser_verify_text_visible',\n    VERIFY_VALUE: 'browser_verify_value',\n    GENERATE_LOCATOR: 'browser_generate_locator',\n} as const;\n\n/**\n * Filesystem tool names for reference\n */\nexport const FILESYSTEM_TOOLS = {\n    READ_FILE: 'read_file',\n    WRITE_FILE: 'write_file',\n    LIST_FILES: 'list_files',\n    SEARCH_FILES: 'search_files',\n} as const;\n\n/**\n * Context7 tool names for reference\n */\nexport const CONTEXT7_TOOLS = {\n    /** Resolve library name to Context7 ID */\n    RESOLVE_LIBRARY_ID: 'resolve-library-id',\n    /** Get library documentation */\n    GET_LIBRARY_DOCS: 'get-library-docs',\n} as const;\n\n/**\n * Vite React tool names for reference\n */\nexport const VITE_REACT_TOOLS = {\n    /** Highlight a React component */\n    HIGHLIGHT_COMPONENT: 'highlight-component',\n    /** Get component props, states, contexts */\n    GET_COMPONENT_STATES: 'get-component-states',\n    /** Get component tree */\n    GET_COMPONENT_TREE: 'get-component-tree',\n    /** Get unnecessary re-renders */\n    GET_UNNECESSARY_RERENDERS: 'get-unnecessary-rerenders',\n} as const;\n\n/**\n * GitHub MCP tool names for reference\n *\n * From @modelcontextprotocol/server-github\n */\nexport const GITHUB_TOOLS = {\n    /** Post a comment on an issue or PR */\n    ADD_ISSUE_COMMENT: 'add_issue_comment',\n    /** Create a new issue */\n    CREATE_ISSUE: 'create_issue',\n    /** Get issue details */\n    GET_ISSUE: 'get_issue',\n    /** Update an issue */\n    UPDATE_ISSUE: 'update_issue',\n    /** Search issues */\n    SEARCH_ISSUES: 'search_issues',\n    /** Create a new pull request */\n    CREATE_PULL_REQUEST: 'create_pull_request',\n    /** Get pull request details */\n    GET_PULL_REQUEST: 'get_pull_request',\n    /** Get file contents from a repo */\n    GET_FILE_CONTENTS: 'get_file_contents',\n    /** Create or update a file */\n    CREATE_OR_UPDATE_FILE: 'create_or_update_file',\n    /** List commits */\n    LIST_COMMITS: 'list_commits',\n    /** Fork a repository */\n    FORK_REPOSITORY: 'fork_repository',\n    /** Create a branch */\n    CREATE_BRANCH: 'create_branch',\n} as const;\n"],"mappings":"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","names":[]}