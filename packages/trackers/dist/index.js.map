{"version":3,"sources":["../src/gh-cli.ts","../src/index.ts"],"sourcesContent":["import { execFileSync, spawnSync } from 'node:child_process';\n\n/**\n * Get environment with GitHub token\n */\nfunction getGitHubEnv(): NodeJS.ProcessEnv {\n    const token = process.env.GH_TOKEN || process.env.GITHUB_TOKEN;\n    return token ? { ...process.env, GH_TOKEN: token } : { ...process.env };\n}\n\n/**\n * Run gh CLI command with stdin input\n */\nfunction ghWithInput(args: string[], input: string): string {\n    const result = spawnSync('gh', args, {\n        input,\n        encoding: 'utf-8',\n        env: getGitHubEnv(),\n        maxBuffer: 10 * 1024 * 1024,\n    });\n\n    if (result.error) {\n        throw result.error;\n    }\n    if (result.status !== 0) {\n        throw new Error(result.stderr || `gh command failed with status ${result.status}`);\n    }\n    return result.stdout.trim();\n}\n\nexport function commentOnIssue(issueNumber: number, body: string): void {\n    ghWithInput(['issue', 'comment', String(issueNumber), '--body-file', '-'], body);\n}\n\nexport function commentOnPR(prNumber: number, body: string): void {\n    ghWithInput(['pr', 'comment', String(prNumber), '--body-file', '-'], body);\n}\n","/**\n * Issue Trackers\n *\n * Multi-tracker abstraction for issue management systems.\n * Connect to your issue tracker and manage issues uniformly.\n *\n * Supported Trackers:\n * - GitHub Issues (github)\n * - Beads Issue Tracker (beads) - local-first, AI-native\n * - Jira (jira)\n * - Linear (linear)\n */\n\nexport { BeadsProvider } from './beads.js';\nexport { GitHubProvider } from './github.js';\nexport { JiraProvider } from './jira.js';\nexport { LinearProvider, type LinearConfig } from './linear.js';\nexport * from './gh-cli.js';\nexport * from './types.js';\n\nimport { BeadsProvider } from './beads.js';\nimport { GitHubProvider } from './github.js';\nimport { JiraProvider } from './jira.js';\nimport { LinearProvider } from './linear.js';\nimport type { ProviderConfig, TriageProvider } from './types.js';\n\n/**\n * Create a triage provider from configuration\n */\nexport function createProvider(config: ProviderConfig | any): TriageProvider {\n    const type = config.type || config.provider;\n    switch (type) {\n        case 'github':\n            return new GitHubProvider(config.github || config);\n\n        case 'jira':\n            return new JiraProvider(config.jira || config);\n\n        case 'linear':\n            return new LinearProvider(config.linear || config);\n\n        case 'beads':\n            return new BeadsProvider();\n\n        default:\n            throw new Error(`Unknown provider type: ${type}`);\n    }\n}\n\n/**\n * Detect and create the best provider based on environment\n */\nexport async function createBestProvider(\n    options: { repo?: string; workingDir?: string; preferBeads?: boolean } = {}\n): Promise<TriageProvider> {\n    const workingDir = options.workingDir || process.cwd();\n\n    if (options.repo) {\n        return new GitHubProvider({ type: 'github', repo: options.repo });\n    }\n\n    // Try to detect from environment or git\n    const repo = process.env.GITHUB_REPOSITORY;\n    if (repo) {\n        return new GitHubProvider({ type: 'github', repo });\n    }\n\n    // Try to detect repo from git remote\n    try {\n        const { execFileSync } = await import('node:child_process');\n        const remote = execFileSync('git', ['remote', 'get-url', 'origin'], {\n            cwd: workingDir,\n            encoding: 'utf-8',\n        }).trim();\n\n        // Parse repo from remote URL\n        const match = remote.match(/github\\.com[/:]([^/]+\\/[^/.]+)/);\n        if (match) {\n            const detectedRepo = match[1].replace(/\\.git$/, '');\n            return new GitHubProvider({ type: 'github', repo: detectedRepo });\n        }\n    } catch {\n        // Not a git repo or no remote\n    }\n\n    throw new Error('Could not auto-detect provider. Please provide configuration.');\n}\n\n// Registry for multi-provider support\nconst providerRegistry = new Map<string, TriageProvider>();\n\n/**\n * Register a provider instance\n */\nexport function registerProvider(name: string, provider: TriageProvider): void {\n    providerRegistry.set(name, provider);\n}\n\n/**\n * Get a registered provider\n */\nexport function getProvider(name: string): TriageProvider | undefined {\n    return providerRegistry.get(name);\n}\n\n/**\n * Get all registered providers\n */\nexport function getAllProviders(): TriageProvider[] {\n    return Array.from(providerRegistry.values());\n}\n\n/**\n * Clear all registered providers\n */\nexport function clearProviders(): void {\n    providerRegistry.clear();\n}\n\n/**\n * Sync all registered providers (for distributed providers like Beads)\n */\nexport async function syncAllProviders(): Promise<void> {\n    const promises: Promise<void>[] = [];\n\n    for (const provider of providerRegistry.values()) {\n        if ('sync' in provider && typeof provider.sync === 'function') {\n            promises.push(provider.sync());\n        }\n    }\n\n    await Promise.all(promises);\n}\n\n/**\n * Get combined statistics from all registered providers\n */\nexport async function getCombinedStats(): Promise<{\n    providers: Record<string, import('./types.js').ProviderStats>;\n    total: import('./types.js').ProviderStats;\n}> {\n    const providers: Record<string, import('./types.js').ProviderStats> = {};\n    const total: import('./types.js').ProviderStats = {\n        total: 0,\n        open: 0,\n        inProgress: 0,\n        blocked: 0,\n        closed: 0,\n        byPriority: { critical: 0, high: 0, medium: 0, low: 0, backlog: 0 },\n        byType: { bug: 0, feature: 0, task: 0, epic: 0, chore: 0, docs: 0 },\n    };\n\n    for (const [name, provider] of providerRegistry) {\n        try {\n            const stats = await provider.getStats();\n            providers[name] = stats;\n\n            // Aggregate\n            total.total += stats.total;\n            total.open += stats.open;\n            total.inProgress += stats.inProgress;\n            total.blocked += stats.blocked;\n            total.closed += stats.closed;\n\n            for (const p of Object.keys(stats.byPriority) as Array<keyof typeof stats.byPriority>) {\n                total.byPriority[p] += stats.byPriority[p];\n            }\n\n            for (const t of Object.keys(stats.byType) as Array<keyof typeof stats.byType>) {\n                total.byType[t] += stats.byType[t];\n            }\n        } catch (err) {\n            console.warn(`Failed to get stats from ${name}:`, err);\n        }\n    }\n\n    return { providers, total };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAAA,SAAuB,iBAAiB;AAKxC,SAAS,eAAkC;AACvC,QAAM,QAAQ,QAAQ,IAAI,YAAY,QAAQ,IAAI;AAClD,SAAO,QAAQ,EAAE,GAAG,QAAQ,KAAK,UAAU,MAAM,IAAI,EAAE,GAAG,QAAQ,IAAI;AAC1E;AAKA,SAAS,YAAY,MAAgB,OAAuB;AACxD,QAAM,SAAS,UAAU,MAAM,MAAM;AAAA,IACjC;AAAA,IACA,UAAU;AAAA,IACV,KAAK,aAAa;AAAA,IAClB,WAAW,KAAK,OAAO;AAAA,EAC3B,CAAC;AAED,MAAI,OAAO,OAAO;AACd,UAAM,OAAO;AAAA,EACjB;AACA,MAAI,OAAO,WAAW,GAAG;AACrB,UAAM,IAAI,MAAM,OAAO,UAAU,iCAAiC,OAAO,MAAM,EAAE;AAAA,EACrF;AACA,SAAO,OAAO,OAAO,KAAK;AAC9B;AAEO,SAAS,eAAe,aAAqB,MAAoB;AACpE,cAAY,CAAC,SAAS,WAAW,OAAO,WAAW,GAAG,eAAe,GAAG,GAAG,IAAI;AACnF;AAEO,SAAS,YAAY,UAAkB,MAAoB;AAC9D,cAAY,CAAC,MAAM,WAAW,OAAO,QAAQ,GAAG,eAAe,GAAG,GAAG,IAAI;AAC7E;;;ACPO,SAAS,eAAe,QAA8C;AACzE,QAAM,OAAO,OAAO,QAAQ,OAAO;AACnC,UAAQ,MAAM;AAAA,IACV,KAAK;AACD,aAAO,IAAI,eAAe,OAAO,UAAU,MAAM;AAAA,IAErD,KAAK;AACD,aAAO,IAAI,aAAa,OAAO,QAAQ,MAAM;AAAA,IAEjD,KAAK;AACD,aAAO,IAAI,eAAe,OAAO,UAAU,MAAM;AAAA,IAErD,KAAK;AACD,aAAO,IAAI,cAAc;AAAA,IAE7B;AACI,YAAM,IAAI,MAAM,0BAA0B,IAAI,EAAE;AAAA,EACxD;AACJ;AAKA,eAAsB,mBAClB,UAAyE,CAAC,GACnD;AACvB,QAAM,aAAa,QAAQ,cAAc,QAAQ,IAAI;AAErD,MAAI,QAAQ,MAAM;AACd,WAAO,IAAI,eAAe,EAAE,MAAM,UAAU,MAAM,QAAQ,KAAK,CAAC;AAAA,EACpE;AAGA,QAAM,OAAO,QAAQ,IAAI;AACzB,MAAI,MAAM;AACN,WAAO,IAAI,eAAe,EAAE,MAAM,UAAU,KAAK,CAAC;AAAA,EACtD;AAGA,MAAI;AACA,UAAM,EAAE,cAAAA,cAAa,IAAI,MAAM,OAAO,eAAoB;AAC1D,UAAM,SAASA,cAAa,OAAO,CAAC,UAAU,WAAW,QAAQ,GAAG;AAAA,MAChE,KAAK;AAAA,MACL,UAAU;AAAA,IACd,CAAC,EAAE,KAAK;AAGR,UAAM,QAAQ,OAAO,MAAM,gCAAgC;AAC3D,QAAI,OAAO;AACP,YAAM,eAAe,MAAM,CAAC,EAAE,QAAQ,UAAU,EAAE;AAClD,aAAO,IAAI,eAAe,EAAE,MAAM,UAAU,MAAM,aAAa,CAAC;AAAA,IACpE;AAAA,EACJ,QAAQ;AAAA,EAER;AAEA,QAAM,IAAI,MAAM,+DAA+D;AACnF;AAGA,IAAM,mBAAmB,oBAAI,IAA4B;AAKlD,SAAS,iBAAiB,MAAc,UAAgC;AAC3E,mBAAiB,IAAI,MAAM,QAAQ;AACvC;AAKO,SAAS,YAAY,MAA0C;AAClE,SAAO,iBAAiB,IAAI,IAAI;AACpC;AAKO,SAAS,kBAAoC;AAChD,SAAO,MAAM,KAAK,iBAAiB,OAAO,CAAC;AAC/C;AAKO,SAAS,iBAAuB;AACnC,mBAAiB,MAAM;AAC3B;AAKA,eAAsB,mBAAkC;AACpD,QAAM,WAA4B,CAAC;AAEnC,aAAW,YAAY,iBAAiB,OAAO,GAAG;AAC9C,QAAI,UAAU,YAAY,OAAO,SAAS,SAAS,YAAY;AAC3D,eAAS,KAAK,SAAS,KAAK,CAAC;AAAA,IACjC;AAAA,EACJ;AAEA,QAAM,QAAQ,IAAI,QAAQ;AAC9B;AAKA,eAAsB,mBAGnB;AACC,QAAM,YAAgE,CAAC;AACvE,QAAM,QAA4C;AAAA,IAC9C,OAAO;AAAA,IACP,MAAM;AAAA,IACN,YAAY;AAAA,IACZ,SAAS;AAAA,IACT,QAAQ;AAAA,IACR,YAAY,EAAE,UAAU,GAAG,MAAM,GAAG,QAAQ,GAAG,KAAK,GAAG,SAAS,EAAE;AAAA,IAClE,QAAQ,EAAE,KAAK,GAAG,SAAS,GAAG,MAAM,GAAG,MAAM,GAAG,OAAO,GAAG,MAAM,EAAE;AAAA,EACtE;AAEA,aAAW,CAAC,MAAM,QAAQ,KAAK,kBAAkB;AAC7C,QAAI;AACA,YAAM,QAAQ,MAAM,SAAS,SAAS;AACtC,gBAAU,IAAI,IAAI;AAGlB,YAAM,SAAS,MAAM;AACrB,YAAM,QAAQ,MAAM;AACpB,YAAM,cAAc,MAAM;AAC1B,YAAM,WAAW,MAAM;AACvB,YAAM,UAAU,MAAM;AAEtB,iBAAW,KAAK,OAAO,KAAK,MAAM,UAAU,GAA2C;AACnF,cAAM,WAAW,CAAC,KAAK,MAAM,WAAW,CAAC;AAAA,MAC7C;AAEA,iBAAW,KAAK,OAAO,KAAK,MAAM,MAAM,GAAuC;AAC3E,cAAM,OAAO,CAAC,KAAK,MAAM,OAAO,CAAC;AAAA,MACrC;AAAA,IACJ,SAAS,KAAK;AACV,cAAQ,KAAK,4BAA4B,IAAI,KAAK,GAAG;AAAA,IACzD;AAAA,EACJ;AAEA,SAAO,EAAE,WAAW,MAAM;AAC9B;","names":["execFileSync"]}