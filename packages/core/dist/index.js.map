{"version":3,"sources":["../src/scoring/agents.ts","../src/scoring/weights.ts","../src/scoring/evaluator.ts","../src/scoring/router.ts","../src/storage/file.ts","../src/storage/github-issue.ts","../src/storage/memory.ts","../src/escalation/config.ts","../src/escalation/cost-tracker.ts","../src/escalation/state.ts","../src/escalation/ladder.ts","../src/queue/lock.ts","../src/queue/manager.ts","../src/queue/priority.ts","../src/test-results.ts","../src/playwright.ts"],"sourcesContent":["/**\n * Provider-Agnostic Agent Interfaces\n *\n * This module defines ONLY the interfaces and registry.\n * Actual provider implementations (Ollama, Jules, Cursor, etc.)\n * belong in @agentic/control where users configure their stack.\n *\n * The key insight: developers can use ANY LLM/agent provider\n * by implementing the AgentExecutor interface and registering\n * it with their desired priority and cost weights.\n */\n\nimport type { ComplexityTier } from './weights.js';\n\n// ============================================================================\n// Core Interfaces - Provider Agnostic\n// ============================================================================\n\n/**\n * What an agent is capable of doing\n */\nexport interface AgentCapabilities {\n    /** Complexity tiers this agent can handle */\n    tiers: ComplexityTier[];\n    /** Maximum context length (tokens/chars) */\n    maxContext?: number;\n    /** Can this agent create PRs? */\n    canCreatePR?: boolean;\n    /** Can this agent run commands? */\n    canExecute?: boolean;\n    /** Is this agent async (returns job ID to poll)? */\n    async?: boolean;\n    /** Custom capability flags */\n    [key: string]: unknown;\n}\n\n/**\n * A task to be processed by an agent\n */\nexport interface AgentTask {\n    /** Unique task identifier */\n    id: string;\n    /** Task description/prompt */\n    description: string;\n    /** Code/diff context */\n    context: string;\n    /** Pre-computed complexity score (0-10) */\n    complexityScore: number;\n    /** Pre-computed complexity tier */\n    complexityTier: ComplexityTier;\n    /** Repository reference (optional) */\n    repo?: string;\n    /** Additional metadata for provider-specific needs */\n    metadata?: Record<string, unknown>;\n}\n\n/**\n * Result from an agent execution\n */\nexport interface AgentResult<T = unknown> {\n    /** Whether the task was completed successfully */\n    success: boolean;\n    /** Result data (provider-specific) */\n    data?: T;\n    /** Error message if failed */\n    error?: string;\n    /** Should router escalate to next agent? */\n    escalate?: boolean;\n    /** Actual cost incurred (in your cost units) */\n    cost: number;\n    /** For async agents: job ID to poll for completion */\n    jobId?: string;\n}\n\n/**\n * Function signature for agent execution\n * Implement this interface to add any LLM/agent provider\n */\nexport type AgentExecutor<T = unknown> = (task: AgentTask) => Promise<AgentResult<T>>;\n\n/**\n * Complete agent definition\n */\nexport interface AgentDefinition<T = unknown> {\n    /** Unique identifier (e.g., 'ollama-qwen', 'jules', 'openai-gpt4') */\n    id: string;\n    /** Human-readable name */\n    name: string;\n    /**\n     * Cost per invocation in your chosen units\n     * Could be cents, tokens, or relative units (0=free, 100=expensive)\n     */\n    cost: number;\n    /**\n     * Priority when multiple agents can handle same tier\n     * Lower = preferred (will be tried first)\n     */\n    priority: number;\n    /** What this agent can do */\n    capabilities: AgentCapabilities;\n    /** Whether this agent is currently enabled */\n    enabled: boolean;\n    /**\n     * Require explicit approval before using?\n     * Useful for expensive agents - task.metadata.approved must include this agent's ID\n     */\n    requiresApproval?: boolean;\n    /** The executor function - implement this for your provider */\n    execute: AgentExecutor<T>;\n}\n\n// ============================================================================\n// Agent Registry - The Core Primitive\n// ============================================================================\n\n/**\n * Registry for managing available agents\n *\n * @example\n * ```typescript\n * const registry = new AgentRegistry();\n *\n * // Register your agents (implementations from @agentic/control or custom)\n * registry.register(myOllamaAgent);\n * registry.register(myJulesAgent);\n * registry.register(myCustomAgent);\n *\n * // Get best agent for a complexity tier\n * const agent = registry.optimalFor('moderate');\n * ```\n */\nexport class AgentRegistry {\n    private agents: Map<string, AgentDefinition> = new Map();\n\n    /**\n     * Register an agent\n     */\n    register<T>(agent: AgentDefinition<T>): this {\n        this.agents.set(agent.id, agent as AgentDefinition);\n        return this;\n    }\n\n    /**\n     * Register multiple agents at once\n     */\n    registerAll(agents: AgentDefinition[]): this {\n        for (const agent of agents) {\n            this.register(agent);\n        }\n        return this;\n    }\n\n    /**\n     * Unregister an agent\n     */\n    unregister(id: string): boolean {\n        return this.agents.delete(id);\n    }\n\n    /**\n     * Enable/disable an agent at runtime\n     */\n    setEnabled(id: string, enabled: boolean): void {\n        const agent = this.agents.get(id);\n        if (agent) {\n            agent.enabled = enabled;\n        }\n    }\n\n    /**\n     * Update an agent's priority (for dynamic rebalancing)\n     */\n    setPriority(id: string, priority: number): void {\n        const agent = this.agents.get(id);\n        if (agent) {\n            agent.priority = priority;\n        }\n    }\n\n    /**\n     * Update an agent's cost (for dynamic pricing)\n     */\n    setCost(id: string, cost: number): void {\n        const agent = this.agents.get(id);\n        if (agent) {\n            agent.cost = cost;\n        }\n    }\n\n    /**\n     * Get all registered agents\n     */\n    all(): AgentDefinition[] {\n        return Array.from(this.agents.values());\n    }\n\n    /**\n     * Get all enabled agents\n     */\n    enabled(): AgentDefinition[] {\n        return this.all().filter((a) => a.enabled);\n    }\n\n    /**\n     * Get agents that can handle a specific complexity tier\n     * Sorted by priority (lowest first), then by cost\n     */\n    forTier(tier: ComplexityTier, includeDisabled = false): AgentDefinition[] {\n        return this.all()\n            .filter((a) => (includeDisabled || a.enabled) && a.capabilities.tiers.includes(tier))\n            .sort((a, b) => {\n                // First by priority (lower = better)\n                if (a.priority !== b.priority) return a.priority - b.priority;\n                // Then by cost (lower = better)\n                return a.cost - b.cost;\n            });\n    }\n\n    /**\n     * Get the optimal (first choice) agent for a complexity tier\n     */\n    optimalFor(tier: ComplexityTier): AgentDefinition | undefined {\n        return this.forTier(tier)[0];\n    }\n\n    /**\n     * Get agent by ID\n     */\n    get(id: string): AgentDefinition | undefined {\n        return this.agents.get(id);\n    }\n\n    /**\n     * Check if an agent is registered\n     */\n    has(id: string): boolean {\n        return this.agents.has(id);\n    }\n\n    /**\n     * Get count of registered agents\n     */\n    get size(): number {\n        return this.agents.size;\n    }\n\n    /**\n     * Clear all agents\n     */\n    clear(): void {\n        this.agents.clear();\n    }\n\n    /**\n     * Export registry configuration (for serialization)\n     */\n    export(): Array<Omit<AgentDefinition, 'execute'>> {\n        return this.all().map(({ execute, ...rest }) => rest);\n    }\n}\n\n// ============================================================================\n// Factory Helper Types\n// ============================================================================\n\n/**\n * Configuration for creating an agent (without the executor)\n * Used by @agentic/control to create provider-specific agents\n */\nexport type AgentConfig = Omit<AgentDefinition, 'execute'>;\n\n/**\n * Factory function type for creating agents\n * Providers implement this to create configured agents\n */\nexport type AgentFactory<TConfig, TResult = unknown> = (\n    id: string,\n    config: TConfig,\n    options?: Partial<AgentConfig>\n) => AgentDefinition<TResult>;\n","/**\n * Default weights for complexity scoring dimensions\n * These can be calibrated over time based on outcome data\n */\n\nexport interface ComplexityWeights {\n    files_changed: number;\n    lines_changed: number;\n    dependency_depth: number;\n    test_coverage_need: number;\n    cross_module_impact: number;\n    semantic_complexity: number;\n    context_required: number;\n    risk_level: number;\n}\n\nexport const DEFAULT_WEIGHTS: ComplexityWeights = {\n    files_changed: 0.15,\n    lines_changed: 0.1,\n    dependency_depth: 0.15,\n    test_coverage_need: 0.1,\n    cross_module_impact: 0.15,\n    semantic_complexity: 0.2,\n    context_required: 0.1,\n    risk_level: 0.05,\n};\n\n/**\n * Tier thresholds for routing decisions\n */\nexport interface TierThresholds {\n    trivial: number; // 0 to this = trivial\n    simple: number; // trivial to this = simple\n    moderate: number; // simple to this = moderate\n    complex: number; // moderate to this = complex\n    // above complex = expert\n}\n\nexport const DEFAULT_THRESHOLDS: TierThresholds = {\n    trivial: 2.5,\n    simple: 5.0,\n    moderate: 7.0,\n    complex: 8.5,\n};\n\nexport type ComplexityTier = 'trivial' | 'simple' | 'moderate' | 'complex' | 'expert';\nexport type AgentTier = 'ollama' | 'jules' | 'cursor';\n\n/**\n * Map complexity tier to recommended agent\n */\nexport function tierToAgent(tier: ComplexityTier, cursorEnabled = false): AgentTier {\n    switch (tier) {\n        case 'trivial':\n        case 'simple':\n            return 'ollama';\n        case 'moderate':\n        case 'complex':\n            return 'jules';\n        case 'expert':\n            // Only use cursor if explicitly enabled, otherwise stay with jules\n            return cursorEnabled ? 'cursor' : 'jules';\n    }\n}\n\n/**\n * Determine tier from weighted score\n */\nexport function scoreToTier(score: number, thresholds = DEFAULT_THRESHOLDS): ComplexityTier {\n    if (score <= thresholds.trivial) return 'trivial';\n    if (score <= thresholds.simple) return 'simple';\n    if (score <= thresholds.moderate) return 'moderate';\n    if (score <= thresholds.complex) return 'complex';\n    return 'expert';\n}\n\n/**\n * Calculate weighted score from raw dimension scores\n */\nexport function calculateWeightedScore(\n    raw: Record<string, number>,\n    weights: ComplexityWeights = DEFAULT_WEIGHTS\n): number {\n    let score = 0;\n    for (const [key, weight] of Object.entries(weights)) {\n        score += weight * (raw[key] ?? 0);\n    }\n    return Math.round(score * 100) / 100; // Round to 2 decimal places\n}\n","/**\n * Sigma-Weighted Complexity Evaluator\n *\n * This module provides the core complexity scoring algorithm.\n * The actual LLM call is abstracted - users provide an evaluator function.\n *\n * The sigma-weighted system allows AI to assess task complexity\n * across multiple dimensions, producing a weighted score that\n * determines optimal agent routing.\n */\n\nimport {\n    type ComplexityTier,\n    type ComplexityWeights,\n    calculateWeightedScore,\n    DEFAULT_THRESHOLDS,\n    DEFAULT_WEIGHTS,\n    scoreToTier,\n    type TierThresholds,\n} from './weights.js';\n\n// ============================================================================\n// Core Types\n// ============================================================================\n\n/**\n * Raw dimension scores from evaluation (0-10 each)\n */\nexport interface DimensionScores {\n    files_changed: number;\n    lines_changed: number;\n    dependency_depth: number;\n    test_coverage_need: number;\n    cross_module_impact: number;\n    semantic_complexity: number;\n    context_required: number;\n    risk_level: number;\n    [key: string]: number; // Allow custom dimensions\n}\n\n/**\n * Complete complexity score result\n */\nexport interface ComplexityScore {\n    /** Raw scores for each dimension (0-10) */\n    raw: DimensionScores;\n    /** Weighted composite score (0-10) */\n    weighted: number;\n    /** Complexity tier based on thresholds */\n    tier: ComplexityTier;\n    /** AI's reasoning for the scores */\n    reasoning: string;\n}\n\n/**\n * Function that performs the actual LLM evaluation\n * Implement this for your LLM provider (Ollama, OpenAI, etc.)\n */\nexport type LLMEvaluator = (prompt: string) => Promise<string>;\n\n/**\n * Configuration for complexity evaluation\n */\nexport interface EvaluatorConfig {\n    /** Custom weights (defaults to DEFAULT_WEIGHTS) */\n    weights?: ComplexityWeights;\n    /** Custom tier thresholds (defaults to DEFAULT_THRESHOLDS) */\n    thresholds?: TierThresholds;\n    /** Maximum context length to send to LLM */\n    maxContextLength?: number;\n}\n\n// ============================================================================\n// The Evaluation Prompt - The Heart of Sigma Scoring\n// ============================================================================\n\n/**\n * Generate the evaluation prompt for an LLM\n * This prompt is provider-agnostic - works with any LLM\n */\nexport function generateEvaluationPrompt(task: string, context: string, maxContext = 8000): string {\n    return `You are a code complexity evaluator. Analyze this task and score each dimension 0-10.\n\nTASK:\n${task}\n\nCONTEXT:\n${context.slice(0, maxContext)}\n\nScore each dimension (0=trivial, 10=extremely complex):\n\n1. files_changed: How many files are affected?\n   0=1 file, 3=2-5 files, 6=5-10 files, 10=10+ files\n\n2. lines_changed: Volume of changes?\n   0=<10 lines, 3=10-50, 6=50-200, 10=200+\n\n3. dependency_depth: How deep are the import chains?\n   0=no deps, 3=local deps, 6=cross-module, 10=cross-repo\n\n4. test_coverage_need: How much testing is required?\n   0=none, 3=unit tests, 6=integration tests, 10=e2e + manual\n\n5. cross_module_impact: Does this affect other parts of the system?\n   0=isolated, 3=same module, 6=multiple modules, 10=system-wide\n\n6. semantic_complexity: How complex is the logic?\n   0=formatting, 3=simple fix, 6=new feature, 10=algorithm design\n\n7. context_required: How much codebase knowledge is needed?\n   0=none, 3=file context, 6=module context, 10=full architecture\n\n8. risk_level: Could this break things?\n   0=no risk, 3=minor, 6=moderate, 10=critical path\n\nRespond ONLY with valid JSON (no markdown, no explanation outside JSON):\n{\n  \"files_changed\": <0-10>,\n  \"lines_changed\": <0-10>,\n  \"dependency_depth\": <0-10>,\n  \"test_coverage_need\": <0-10>,\n  \"cross_module_impact\": <0-10>,\n  \"semantic_complexity\": <0-10>,\n  \"context_required\": <0-10>,\n  \"risk_level\": <0-10>,\n  \"reasoning\": \"<one sentence explanation>\"\n}`;\n}\n\n// ============================================================================\n// Core Evaluation Functions\n// ============================================================================\n\n/**\n * Parse and validate LLM response into dimension scores\n */\nexport function parseEvaluationResponse(\n    response: string,\n    weights: ComplexityWeights = DEFAULT_WEIGHTS\n): { scores: DimensionScores; reasoning: string } {\n    // Try to extract JSON from response (handle markdown code blocks)\n    let json = response;\n    const jsonMatch = response.match(/```(?:json)?\\s*([\\s\\S]*?)```/);\n    if (jsonMatch) {\n        json = jsonMatch[1];\n    }\n\n    const parsed = JSON.parse(json.trim());\n\n    // Validate and clamp scores to 0-10\n    const scores: DimensionScores = {\n        files_changed: 0,\n        lines_changed: 0,\n        dependency_depth: 0,\n        test_coverage_need: 0,\n        cross_module_impact: 0,\n        semantic_complexity: 0,\n        context_required: 0,\n        risk_level: 0,\n    };\n\n    for (const key of Object.keys(weights)) {\n        const val = Number(parsed[key]) || 0;\n        scores[key] = Math.max(0, Math.min(10, val));\n    }\n\n    return {\n        scores,\n        reasoning: parsed.reasoning || 'No reasoning provided',\n    };\n}\n\n/**\n * Calculate complexity score from parsed dimension scores\n */\nexport function calculateComplexity(\n    scores: DimensionScores,\n    config: EvaluatorConfig = {}\n): Omit<ComplexityScore, 'reasoning'> {\n    const { weights = DEFAULT_WEIGHTS, thresholds = DEFAULT_THRESHOLDS } = config;\n\n    const weighted = calculateWeightedScore(scores, weights);\n    const tier = scoreToTier(weighted, thresholds);\n\n    return {\n        raw: scores,\n        weighted,\n        tier,\n    };\n}\n\n/**\n * Full evaluation using an LLM\n *\n * @example\n * ```typescript\n * // With Ollama\n * const evaluate = async (prompt: string) => {\n *   const res = await fetch('http://localhost:11434/api/generate', {\n *     method: 'POST',\n *     body: JSON.stringify({ model: 'qwen2.5-coder', prompt, stream: false })\n *   });\n *   return (await res.json()).response;\n * };\n *\n * const score = await evaluateComplexity(evaluate, 'Fix the bug', codeDiff);\n * console.log(score.tier); // 'simple'\n * console.log(score.weighted); // 3.5\n * ```\n */\nexport async function evaluateComplexity(\n    llm: LLMEvaluator,\n    task: string,\n    context: string,\n    config: EvaluatorConfig = {}\n): Promise<ComplexityScore> {\n    const prompt = generateEvaluationPrompt(task, context, config.maxContextLength);\n    const response = await llm(prompt);\n    const { scores, reasoning } = parseEvaluationResponse(response, config.weights);\n    const result = calculateComplexity(scores, config);\n\n    return {\n        ...result,\n        reasoning,\n    };\n}\n\n// ============================================================================\n// Heuristic Fallback (No LLM Required)\n// ============================================================================\n\n/**\n * Quick complexity estimation without AI (heuristic-based)\n * Useful when LLM is unavailable or for fast pre-filtering\n */\nexport function estimateComplexityHeuristic(\n    options: {\n        filesChanged?: number;\n        linesChanged?: number;\n        hasTests?: boolean;\n        isRefactor?: boolean;\n        hasDependencyChanges?: boolean;\n        isCriticalPath?: boolean;\n    },\n    config: EvaluatorConfig = {}\n): ComplexityScore {\n    const {\n        filesChanged = 1,\n        linesChanged = 10,\n        hasTests = true,\n        isRefactor = false,\n        hasDependencyChanges = false,\n        isCriticalPath = false,\n    } = options;\n\n    const scores: DimensionScores = {\n        files_changed: Math.min(10, filesChanged),\n        lines_changed: Math.min(10, Math.log10(linesChanged + 1) * 3),\n        dependency_depth: hasDependencyChanges ? 6 : isRefactor ? 4 : 2,\n        test_coverage_need: hasTests ? 3 : 6,\n        cross_module_impact: filesChanged > 5 ? 7 : filesChanged > 2 ? 4 : 1,\n        semantic_complexity: isRefactor ? 6 : 3,\n        context_required: filesChanged > 3 ? 6 : 3,\n        risk_level: isCriticalPath ? 8 : isRefactor ? 5 : 2,\n    };\n\n    const result = calculateComplexity(scores, config);\n\n    return {\n        ...result,\n        reasoning: 'Heuristic estimation (no LLM evaluation)',\n    };\n}\n","/**\n * Intelligent Task Router\n *\n * Routes tasks to optimal agents based on:\n * 1. Sigma-weighted complexity scores\n * 2. Agent capabilities and availability\n * 3. Cost optimization (prefer cheaper agents)\n * 4. Escalation on failure\n */\n\nimport type { AgentDefinition, AgentRegistry, AgentResult, AgentTask } from './agents.js';\nimport type { ComplexityScore } from './evaluator.js';\nimport type { ComplexityTier } from './weights.js';\n\nexport interface RouterConfig {\n    /** Agent registry with available agents */\n    registry: AgentRegistry;\n    /** Maximum retries per agent before escalating */\n    maxRetries?: number;\n    /** Daily cost budget (0 = unlimited) */\n    dailyBudget?: number;\n    /** Callback when an agent is selected */\n    onAgentSelected?: (agent: AgentDefinition, task: AgentTask) => void;\n    /** Callback when escalating */\n    onEscalate?: (fromAgent: AgentDefinition, toAgent: AgentDefinition, reason: string) => void;\n    /** Callback for cost tracking */\n    onCostIncurred?: (agent: AgentDefinition, cost: number, task: AgentTask) => void;\n}\n\nexport interface RoutingResult<T = unknown> {\n    /** Whether the task was successfully completed */\n    success: boolean;\n    /** Which agent handled the task */\n    agent: string;\n    /** The result from the agent */\n    result: AgentResult<T>;\n    /** Total cost incurred */\n    totalCost: number;\n    /** Number of attempts made */\n    attempts: number;\n    /** Trail of agents tried */\n    trail: Array<{ agent: string; success: boolean; error?: string }>;\n}\n\nexport interface RouterState {\n    /** Costs incurred today */\n    dailyCosts: number;\n    /** Last reset timestamp */\n    lastReset: string;\n    /** Tasks processed today */\n    tasksProcessed: number;\n}\n\n/**\n * Task Router - intelligently routes tasks to agents\n */\nexport class TaskRouter {\n    private config: Required<Omit<RouterConfig, 'onAgentSelected' | 'onEscalate' | 'onCostIncurred'>> &\n        Pick<RouterConfig, 'onAgentSelected' | 'onEscalate' | 'onCostIncurred'>;\n    private state: RouterState;\n\n    constructor(config: RouterConfig) {\n        this.config = {\n            maxRetries: 2,\n            dailyBudget: 0,\n            ...config,\n        };\n        this.state = {\n            dailyCosts: 0,\n            lastReset: new Date().toISOString().split('T')[0],\n            tasksProcessed: 0,\n        };\n    }\n\n    /**\n     * Route a task to the optimal agent\n     */\n    async route(\n        task: Omit<AgentTask, 'complexityScore' | 'complexityTier'>,\n        complexity: ComplexityScore\n    ): Promise<RoutingResult> {\n        this.maybeResetDaily();\n\n        const fullTask: AgentTask = {\n            ...task,\n            complexityScore: complexity.weighted,\n            complexityTier: complexity.tier,\n        };\n\n        const trail: RoutingResult['trail'] = [];\n        let totalCost = 0;\n\n        // Try each tier from current to expert\n        const tierOrder: ComplexityTier[] = ['trivial', 'simple', 'moderate', 'complex', 'expert'];\n        const startIndex = tierOrder.indexOf(complexity.tier);\n\n        for (let i = startIndex; i < tierOrder.length; i++) {\n            const tier = tierOrder[i];\n            const agents = this.config.registry.forTier(tier);\n\n            for (const agent of agents) {\n                if (!this.canUseAgent(agent, fullTask)) {\n                    continue;\n                }\n\n                const result = await this.tryAgent(agent, fullTask, trail);\n                totalCost += result.totalCost;\n\n                if (result.success && result.agentResult) {\n                    this.state.tasksProcessed++;\n                    return {\n                        success: true,\n                        agent: agent.id,\n                        result: result.agentResult,\n                        totalCost,\n                        attempts: trail.length,\n                        trail,\n                    };\n                }\n\n                // If agent failed but next agent in same tier exists, escalate\n                const nextAgent = agents[agents.indexOf(agent) + 1];\n                if (nextAgent) {\n                    this.config.onEscalate?.(agent, nextAgent, 'Agent failed');\n                }\n            }\n        }\n\n        // All agents exhausted\n        this.state.tasksProcessed++;\n        return {\n            success: false,\n            agent: 'none',\n            result: { success: false, error: 'All agents exhausted', cost: 0 },\n            totalCost,\n            attempts: trail.length,\n            trail,\n        };\n    }\n\n    /**\n     * Check if an agent can be used for a task\n     */\n    private canUseAgent(agent: AgentDefinition, task: AgentTask): boolean {\n        // Check approval requirement\n        if (agent.requiresApproval && !this.hasApproval(task, agent)) {\n            return false;\n        }\n\n        // Check budget\n        if (this.config.dailyBudget > 0 && this.state.dailyCosts + agent.cost > this.config.dailyBudget) {\n            return false;\n        }\n\n        return true;\n    }\n\n    /**\n     * Try an agent with retries\n     */\n    private async tryAgent(\n        agent: AgentDefinition,\n        task: AgentTask,\n        trail: RoutingResult['trail']\n    ): Promise<{ success: boolean; totalCost: number; agentResult?: AgentResult }> {\n        let totalCost = 0;\n\n        for (let attempt = 0; attempt <= this.config.maxRetries; attempt++) {\n            this.config.onAgentSelected?.(agent, task);\n\n            try {\n                const result = await agent.execute(task);\n                totalCost += result.cost;\n                this.state.dailyCosts += result.cost;\n                this.config.onCostIncurred?.(agent, result.cost, task);\n\n                trail.push({\n                    agent: agent.id,\n                    success: result.success,\n                    error: result.error,\n                });\n\n                if (result.success) {\n                    return { success: true, totalCost, agentResult: result };\n                }\n\n                // If agent says don't retry, break to next agent\n                if (result.escalate || attempt >= this.config.maxRetries) {\n                    return { success: false, totalCost, agentResult: result };\n                }\n            } catch (error) {\n                const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n                trail.push({ agent: agent.id, success: false, error: errorMessage });\n                if (attempt >= this.config.maxRetries) {\n                    return { success: false, totalCost };\n                }\n            }\n        }\n\n        return { success: false, totalCost };\n    }\n\n    /**\n     * Check if a task has approval for an agent that requires it\n     */\n    private hasApproval(task: AgentTask, agent: AgentDefinition): boolean {\n        // Check metadata for approval flag\n        const approved = task.metadata?.approved as string[] | undefined;\n        return approved?.includes(agent.id) ?? false;\n    }\n\n    /**\n     * Reset daily state if it's a new day\n     */\n    private maybeResetDaily(): void {\n        const today = new Date().toISOString().split('T')[0];\n        if (this.state.lastReset !== today) {\n            this.state = {\n                dailyCosts: 0,\n                lastReset: today,\n                tasksProcessed: 0,\n            };\n        }\n    }\n\n    /**\n     * Get current router state\n     */\n    getState(): RouterState {\n        return { ...this.state };\n    }\n\n    /**\n     * Get remaining daily budget\n     */\n    getRemainingBudget(): number {\n        if (this.config.dailyBudget === 0) return Number.POSITIVE_INFINITY;\n        return Math.max(0, this.config.dailyBudget - this.state.dailyCosts);\n    }\n}\n\n/**\n * Create a simple router with default configuration\n */\nexport function createRouter(registry: AgentRegistry, options?: Partial<RouterConfig>): TaskRouter {\n    return new TaskRouter({ registry, ...options });\n}\n","/**\n * File Storage\n *\n * Persists queue state to a JSON file on disk.\n * Useful for local testing and single-machine deployments.\n */\n\nimport { mkdir, readFile, writeFile } from 'node:fs/promises';\nimport { dirname } from 'node:path';\nimport type { QueueItem, QueueLock, QueueState } from '../queue/types.js';\nimport type { QueueStorage } from './interface.js';\n\n/**\n * File-based storage implementation\n */\nexport class FileStorage<T extends QueueItem = QueueItem> implements QueueStorage<T> {\n    constructor(private readonly filePath: string) {}\n\n    async read(): Promise<QueueState<T>> {\n        try {\n            const content = await readFile(this.filePath, 'utf-8');\n            return JSON.parse(content);\n        } catch (error) {\n            // File doesn't exist, return empty state\n            if ((error as NodeJS.ErrnoException).code === 'ENOENT') {\n                return this.createEmptyState();\n            }\n            throw error;\n        }\n    }\n\n    async write(state: QueueState<T>): Promise<void> {\n        // Ensure directory exists\n        await mkdir(dirname(this.filePath), { recursive: true });\n\n        const updatedState = {\n            ...state,\n            updatedAt: new Date().toISOString(),\n        };\n\n        await writeFile(this.filePath, JSON.stringify(updatedState, null, 2), 'utf-8');\n    }\n\n    async acquireLock(holder: string, ttlMs: number): Promise<boolean> {\n        const state = await this.read();\n\n        if (state.lock) {\n            const expires = new Date(state.lock.expiresAt);\n            if (expires > new Date()) {\n                return state.lock.holder === holder;\n            }\n        }\n\n        state.lock = {\n            holder,\n            acquiredAt: new Date().toISOString(),\n            expiresAt: new Date(Date.now() + ttlMs).toISOString(),\n        };\n\n        await this.write(state);\n        return true;\n    }\n\n    async releaseLock(holder: string): Promise<void> {\n        const state = await this.read();\n\n        if (state.lock?.holder === holder) {\n            state.lock = null;\n            await this.write(state);\n        }\n    }\n\n    async isLocked(): Promise<boolean> {\n        const state = await this.read();\n        if (!state.lock) return false;\n        return new Date(state.lock.expiresAt) > new Date();\n    }\n\n    async getLock(): Promise<QueueLock | null> {\n        const state = await this.read();\n        return state.lock;\n    }\n\n    private createEmptyState(): QueueState<T> {\n        return {\n            version: 2,\n            updatedAt: new Date().toISOString(),\n            lock: null,\n            items: [],\n            stats: {\n                total: 0,\n                byStatus: { pending: 0, processing: 0, completed: 0, failed: 0, cancelled: 0 },\n                completed24h: 0,\n                failed24h: 0,\n                avgProcessingTime: 0,\n            },\n        };\n    }\n}\n","/**\n * GitHub Issue Storage\n *\n * Stores queue state in a GitHub Issue body with:\n * - JSON state in code block between markers\n * - Human-readable status table\n * - Distributed locking via issue comments\n */\n\nimport type { QueueItem, QueueLock, QueueState } from '../queue/types.js';\nimport type { QueueStorage } from './interface.js';\n\nexport interface GitHubIssueStorageOptions {\n    /** Repository in format \"owner/repo\" */\n    repo: string;\n    /** Issue number, or 'auto' to create if doesn't exist */\n    issueNumber: number | 'auto';\n    /** Issue title when auto-creating */\n    issueTitle?: string;\n    /** GitHub token for authentication */\n    token: string;\n    /** Optional Octokit instance (for testing) */\n    octokit?: GitHubIssueStorageOctokit;\n}\n\n/**\n * Minimal Octokit interface for GitHub operations\n * Allows dependency injection for testing\n */\nexport interface GitHubIssueStorageOctokit {\n    rest: {\n        issues: {\n            get(params: { owner: string; repo: string; issue_number: number }): Promise<{\n                data: { body: string | null; number: number };\n            }>;\n            create(params: {\n                owner: string;\n                repo: string;\n                title: string;\n                body: string;\n                labels?: string[];\n            }): Promise<{ data: { number: number } }>;\n            update(params: { owner: string; repo: string; issue_number: number; body: string }): Promise<unknown>;\n            listComments(params: {\n                owner: string;\n                repo: string;\n                issue_number: number;\n                per_page?: number;\n            }): Promise<{ data: Array<{ id: number; body?: string; created_at: string }> }>;\n            createComment(params: {\n                owner: string;\n                repo: string;\n                issue_number: number;\n                body: string;\n            }): Promise<{ data: { id: number } }>;\n            deleteComment(params: { owner: string; repo: string; comment_id: number }): Promise<unknown>;\n        };\n    };\n}\n\nconst STATE_START = '<!-- QUEUE_STATE_START -->';\nconst STATE_END = '<!-- QUEUE_STATE_END -->';\nconst LOCK_COMMENT_PREFIX = 'üîí QUEUE_LOCK:';\n\n/**\n * GitHub Issue storage implementation\n */\nexport class GitHubIssueStorage<T extends QueueItem = QueueItem> implements QueueStorage<T> {\n    private owner: string;\n    private repoName: string;\n    private issueNumber: number | 'auto';\n    private issueTitle: string;\n    private token: string;\n    private octokit: GitHubIssueStorageOctokit | null;\n    private actualIssueNumber: number | null = null;\n    private octokitPromise: Promise<GitHubIssueStorageOctokit> | null = null;\n\n    constructor(options: GitHubIssueStorageOptions) {\n        const [owner, repo] = options.repo.split('/');\n        if (!owner || !repo) {\n            throw new Error('Invalid repo format. Expected \"owner/repo\"');\n        }\n\n        this.owner = owner;\n        this.repoName = repo;\n        this.issueNumber = options.issueNumber;\n        this.issueTitle = options.issueTitle || 'Merge Queue State';\n        this.token = options.token;\n        this.octokit = options.octokit || null;\n    }\n\n    async read(): Promise<QueueState<T>> {\n        const issue = await this.getOrCreateIssue();\n        const body = issue.body || '';\n\n        const parsed = this.parseIssueBody(body);\n        if (parsed) {\n            return parsed;\n        }\n\n        // No state found, return empty state\n        return this.createEmptyState();\n    }\n\n    async write(state: QueueState<T>): Promise<void> {\n        const issue = await this.getOrCreateIssue();\n\n        const updatedState = {\n            ...state,\n            updatedAt: new Date().toISOString(),\n        };\n\n        const body = this.formatIssueBody(updatedState);\n\n        const client = await this.getOctokit();\n        await client.rest.issues.update({\n            owner: this.owner,\n            repo: this.repoName,\n            issue_number: issue.number,\n            body,\n        });\n    }\n\n    async acquireLock(holder: string, ttlMs: number): Promise<boolean> {\n        const issue = await this.getOrCreateIssue();\n        const client = await this.getOctokit();\n\n        // Check existing lock comments\n        const comments = await client.rest.issues.listComments({\n            owner: this.owner,\n            repo: this.repoName,\n            issue_number: issue.number,\n            per_page: 100,\n        });\n\n        const lockComments = comments.data.filter((c) => c.body?.startsWith(LOCK_COMMENT_PREFIX));\n\n        // Check if there's an active lock\n        for (const comment of lockComments) {\n            const lock = this.parseLockComment(comment.body || '');\n            if (lock && new Date(lock.expiresAt) > new Date()) {\n                // Lock is still valid\n                return lock.holder === holder;\n            }\n            // Delete expired lock comment\n            await client.rest.issues.deleteComment({\n                owner: this.owner,\n                repo: this.repoName,\n                comment_id: comment.id,\n            });\n        }\n\n        // Acquire new lock\n        const lock: QueueLock = {\n            holder,\n            acquiredAt: new Date().toISOString(),\n            expiresAt: new Date(Date.now() + ttlMs).toISOString(),\n        };\n\n        await client.rest.issues.createComment({\n            owner: this.owner,\n            repo: this.repoName,\n            issue_number: issue.number,\n            body: `${LOCK_COMMENT_PREFIX} ${JSON.stringify(lock)}`,\n        });\n\n        return true;\n    }\n\n    async releaseLock(holder: string): Promise<void> {\n        const issue = await this.getOrCreateIssue();\n        const client = await this.getOctokit();\n\n        const comments = await client.rest.issues.listComments({\n            owner: this.owner,\n            repo: this.repoName,\n            issue_number: issue.number,\n            per_page: 100,\n        });\n\n        for (const comment of comments.data) {\n            if (comment.body?.startsWith(LOCK_COMMENT_PREFIX)) {\n                const lock = this.parseLockComment(comment.body);\n                if (lock?.holder === holder) {\n                    await client.rest.issues.deleteComment({\n                        owner: this.owner,\n                        repo: this.repoName,\n                        comment_id: comment.id,\n                    });\n                }\n            }\n        }\n    }\n\n    async isLocked(): Promise<boolean> {\n        const lock = await this.getLock();\n        return lock !== null && new Date(lock.expiresAt) > new Date();\n    }\n\n    async getLock(): Promise<QueueLock | null> {\n        const issue = await this.getOrCreateIssue();\n        const client = await this.getOctokit();\n\n        const comments = await client.rest.issues.listComments({\n            owner: this.owner,\n            repo: this.repoName,\n            issue_number: issue.number,\n            per_page: 100,\n        });\n\n        for (const comment of comments.data) {\n            if (comment.body?.startsWith(LOCK_COMMENT_PREFIX)) {\n                const lock = this.parseLockComment(comment.body);\n                if (lock && new Date(lock.expiresAt) > new Date()) {\n                    return lock;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    // ============================================================================\n    // Private Helpers\n    // ============================================================================\n\n    private async getOctokit(): Promise<GitHubIssueStorageOctokit> {\n        if (this.octokit) {\n            return this.octokit;\n        }\n\n        // Cache the import promise to avoid multiple imports\n        if (!this.octokitPromise) {\n            this.octokitPromise = import('octokit').then(({ Octokit }) => {\n                const client = new Octokit({ auth: this.token }) as unknown as GitHubIssueStorageOctokit;\n                this.octokit = client;\n                return client;\n            });\n        }\n\n        return this.octokitPromise;\n    }\n\n    private async getOrCreateIssue(): Promise<{ number: number; body: string | null }> {\n        if (this.actualIssueNumber !== null) {\n            const client = await this.getOctokit();\n            const { data } = await client.rest.issues.get({\n                owner: this.owner,\n                repo: this.repoName,\n                issue_number: this.actualIssueNumber,\n            });\n            return data;\n        }\n\n        if (this.issueNumber === 'auto') {\n            return this.createIssue();\n        }\n\n        const client = await this.getOctokit();\n        const { data } = await client.rest.issues.get({\n            owner: this.owner,\n            repo: this.repoName,\n            issue_number: this.issueNumber,\n        });\n        this.actualIssueNumber = data.number;\n        return data;\n    }\n\n    private async createIssue(): Promise<{ number: number; body: string | null }> {\n        const client = await this.getOctokit();\n        const emptyState = this.createEmptyState();\n        const body = this.formatIssueBody(emptyState);\n\n        const { data } = await client.rest.issues.create({\n            owner: this.owner,\n            repo: this.repoName,\n            title: this.issueTitle,\n            body,\n            labels: ['queue', 'automation'],\n        });\n\n        this.actualIssueNumber = data.number;\n        return { number: data.number, body };\n    }\n\n    private parseIssueBody(body: string): QueueState<T> | null {\n        const startIdx = body.indexOf(STATE_START);\n        const endIdx = body.indexOf(STATE_END);\n\n        if (startIdx === -1 || endIdx === -1) {\n            return null;\n        }\n\n        const jsonBlock = body.substring(startIdx + STATE_START.length, endIdx);\n        const match = jsonBlock.match(/```json\\s*([\\s\\S]*?)\\s*```/);\n\n        if (!match || !match[1]) {\n            return null;\n        }\n\n        try {\n            return JSON.parse(match[1]);\n        } catch {\n            return null;\n        }\n    }\n\n    private formatIssueBody(state: QueueState<T>): string {\n        const json = JSON.stringify(state, null, 2);\n\n        // Build status table\n        const rows = state.items.map((item, idx) => this.formatTableRow(item, idx));\n\n        const table =\n            rows.length > 0\n                ? `| # | PR | Priority | Status |\n|---|-----|----------|--------|\n${rows.join('\\n')}`\n                : '_Queue is empty_';\n\n        return `${STATE_START}\n\\`\\`\\`json\n${json}\n\\`\\`\\`\n${STATE_END}\n\n## Queue Status\n\n${table}\n\n**Stats:**\n- Total: ${state.stats.total}\n- Pending: ${state.stats.byStatus.pending}\n- Processing: ${state.stats.byStatus.processing}\n- Failed: ${state.stats.byStatus.failed}\n\n_Last updated: ${state.updatedAt}_\n`;\n    }\n\n    private formatTableRow(item: T, idx: number): string {\n        const prLink = item.id.includes('#')\n            ? `[${item.id}](https://github.com/${item.id.replace('#', '/pull/')})`\n            : item.id;\n        const priorityEmoji = this.getPriorityEmoji(item.priority);\n        const statusEmoji = this.getStatusEmoji(item.status);\n\n        return `| ${idx + 1} | ${prLink} | ${priorityEmoji} ${item.priority} | ${statusEmoji} ${item.status} |`;\n    }\n\n    private getPriorityEmoji(priority: number): string {\n        if (priority === 1) return 'üî¥';\n        if (priority === 2) return 'üü°';\n        return 'üü¢';\n    }\n\n    private getStatusEmoji(status: string): string {\n        switch (status) {\n            case 'pending':\n                return '‚è≥';\n            case 'processing':\n                return 'üîÑ';\n            case 'completed':\n                return '‚úÖ';\n            case 'failed':\n                return '‚ùå';\n            default:\n                return '‚è∏Ô∏è';\n        }\n    }\n\n    private parseLockComment(body: string): QueueLock | null {\n        if (!body.startsWith(LOCK_COMMENT_PREFIX)) {\n            return null;\n        }\n\n        const jsonStr = body.substring(LOCK_COMMENT_PREFIX.length).trim();\n        try {\n            return JSON.parse(jsonStr);\n        } catch {\n            return null;\n        }\n    }\n\n    private createEmptyState(): QueueState<T> {\n        return {\n            version: 2,\n            updatedAt: new Date().toISOString(),\n            lock: null,\n            items: [],\n            stats: {\n                total: 0,\n                byStatus: { pending: 0, processing: 0, completed: 0, failed: 0, cancelled: 0 },\n                completed24h: 0,\n                failed24h: 0,\n                avgProcessingTime: 0,\n            },\n        };\n    }\n}\n","/**\n * In-Memory Storage\n *\n * Simple in-memory storage implementation for testing.\n * State is lost when the process exits.\n */\n\nimport type { QueueItem, QueueLock, QueueState } from '../queue/types.js';\nimport type { QueueStorage } from './interface.js';\n\n/**\n * In-memory storage for testing\n */\nexport class MemoryStorage<T extends QueueItem = QueueItem> implements QueueStorage<T> {\n    private state: QueueState<T>;\n\n    constructor(initial?: Partial<QueueState<T>>) {\n        this.state = {\n            version: 2,\n            updatedAt: new Date().toISOString(),\n            lock: null,\n            items: [],\n            stats: {\n                total: 0,\n                byStatus: { pending: 0, processing: 0, completed: 0, failed: 0, cancelled: 0 },\n                completed24h: 0,\n                failed24h: 0,\n                avgProcessingTime: 0,\n            },\n            ...initial,\n        };\n    }\n\n    async read(): Promise<QueueState<T>> {\n        return { ...this.state, items: [...this.state.items] };\n    }\n\n    async write(state: QueueState<T>): Promise<void> {\n        this.state = { ...state, updatedAt: new Date().toISOString() };\n    }\n\n    async acquireLock(holder: string, ttlMs: number): Promise<boolean> {\n        if (this.state.lock) {\n            const expires = new Date(this.state.lock.expiresAt);\n            if (expires > new Date()) {\n                return this.state.lock.holder === holder;\n            }\n        }\n\n        this.state.lock = {\n            holder,\n            acquiredAt: new Date().toISOString(),\n            expiresAt: new Date(Date.now() + ttlMs).toISOString(),\n        };\n        return true;\n    }\n\n    async releaseLock(holder: string): Promise<void> {\n        if (this.state.lock?.holder === holder) {\n            this.state.lock = null;\n        }\n    }\n\n    async isLocked(): Promise<boolean> {\n        if (!this.state.lock) return false;\n        return new Date(this.state.lock.expiresAt) > new Date();\n    }\n\n    async getLock(): Promise<QueueLock | null> {\n        return this.state.lock;\n    }\n}\n","/**\n * Escalation Configuration\n *\n * Defines configuration options for the 7-level escalation ladder.\n * Controls retry attempts, cloud agent behavior, and cost budgets.\n */\n\n/**\n * Configuration for the escalation ladder\n */\nexport interface EscalationConfig {\n    /** Maximum number of Ollama fix attempts before escalating (Default: 2) */\n    maxOllamaAttempts: number;\n\n    /** Maximum number of initial Jules attempts before escalating (Default: 3) */\n    maxJulesAttempts: number;\n\n    /** Maximum number of Jules attempts with boosted context (Default: 3) */\n    maxJulesBoostAttempts: number;\n\n    /** Whether cloud agents (e.g., Cursor) are enabled (Default: false) */\n    cloudAgentEnabled: boolean;\n\n    /** Whether cloud agents require explicit approval via label (Default: true) */\n    cloudAgentApprovalRequired: boolean;\n\n    /** Daily cost budget for cloud agents in cents (Default: 0 = no cloud) */\n    costBudgetDaily: number;\n}\n\n/**\n * Default escalation configuration - prioritizes free options\n */\nexport const DEFAULT_ESCALATION_CONFIG: EscalationConfig = {\n    maxOllamaAttempts: 2,\n    maxJulesAttempts: 3,\n    maxJulesBoostAttempts: 3,\n    cloudAgentEnabled: false,\n    cloudAgentApprovalRequired: true,\n    costBudgetDaily: 0,\n};\n\n/**\n * Create escalation config with defaults\n */\nexport function createEscalationConfig(partial?: Partial<EscalationConfig>): EscalationConfig {\n    return {\n        ...DEFAULT_ESCALATION_CONFIG,\n        ...partial,\n    };\n}\n","/**\n * Cost Tracker for Cloud Agents\n *\n * Tracks and enforces daily budget limits for expensive cloud agents.\n * Provides reporting and alerting when approaching budget limits.\n */\n\n/**\n * Cost entry for tracking individual operations\n */\nexport interface CostEntry {\n    /** Timestamp of the operation */\n    timestamp: string;\n    /** Task ID associated with the cost */\n    taskId: string;\n    /** Agent that incurred the cost */\n    agent: string;\n    /** Cost in cents */\n    amount: number;\n    /** Operation description */\n    description: string;\n}\n\n/**\n * Daily cost statistics\n */\nexport interface DailyCostStats {\n    /** Date (YYYY-MM-DD) */\n    date: string;\n    /** Total cost in cents */\n    total: number;\n    /** Number of operations */\n    operations: number;\n    /** Cost by agent */\n    byAgent: Record<string, number>;\n    /** Cost entries */\n    entries: CostEntry[];\n}\n\n/**\n * Cost tracker for managing cloud agent budgets\n */\nexport class CostTracker {\n    private entries: Map<string, CostEntry[]> = new Map();\n    private dailyBudget: number;\n    private onBudgetWarning?: (remaining: number, total: number) => void;\n\n    constructor(\n        dailyBudget: number,\n        options?: {\n            onBudgetWarning?: (remaining: number, total: number) => void;\n        }\n    ) {\n        this.dailyBudget = dailyBudget;\n        this.onBudgetWarning = options?.onBudgetWarning;\n    }\n\n    /**\n     * Record a cost entry\n     */\n    record(taskId: string, agent: string, amount: number, description = 'Cloud agent operation'): CostEntry {\n        const entry: CostEntry = {\n            timestamp: new Date().toISOString(),\n            taskId,\n            agent,\n            amount,\n            description,\n        };\n\n        const today = this.getToday();\n        const dailyEntries = this.entries.get(today) || [];\n        dailyEntries.push(entry);\n        this.entries.set(today, dailyEntries);\n\n        // Check if approaching budget\n        const stats = this.getDailyStats(today);\n        const remaining = this.dailyBudget - stats.total;\n\n        if (remaining <= this.dailyBudget * 0.2 && remaining > 0 && this.onBudgetWarning) {\n            this.onBudgetWarning(remaining, stats.total);\n        }\n\n        return entry;\n    }\n\n    /**\n     * Check if operation is within budget\n     */\n    canAfford(amount: number, date?: string): boolean {\n        if (this.dailyBudget === 0) return false; // Budget of 0 means no cloud agents\n        const today = date || this.getToday();\n        const stats = this.getDailyStats(today);\n        return stats.total + amount <= this.dailyBudget;\n    }\n\n    /**\n     * Get remaining budget for today\n     */\n    getRemainingBudget(date?: string): number {\n        const today = date || this.getToday();\n        const stats = this.getDailyStats(today);\n        return Math.max(0, this.dailyBudget - stats.total);\n    }\n\n    /**\n     * Get daily statistics\n     */\n    getDailyStats(date?: string): DailyCostStats {\n        const today = date || this.getToday();\n        const entries = this.entries.get(today) || [];\n\n        const byAgent: Record<string, number> = {};\n        let total = 0;\n\n        for (const entry of entries) {\n            total += entry.amount;\n            byAgent[entry.agent] = (byAgent[entry.agent] || 0) + entry.amount;\n        }\n\n        return {\n            date: today,\n            total,\n            operations: entries.length,\n            byAgent,\n            entries: [...entries],\n        };\n    }\n\n    /**\n     * Get stats for a date range\n     */\n    getStatsInRange(startDate: string, endDate: string): DailyCostStats[] {\n        const stats: DailyCostStats[] = [];\n        const start = new Date(startDate);\n        const end = new Date(endDate);\n\n        for (let date = new Date(start); date <= end; date.setDate(date.getDate() + 1)) {\n            const dateStr = date.toISOString().split('T')[0];\n            if (this.entries.has(dateStr)) {\n                stats.push(this.getDailyStats(dateStr));\n            }\n        }\n\n        return stats;\n    }\n\n    /**\n     * Get all-time total cost\n     */\n    getTotalCost(): number {\n        let total = 0;\n        const values = Array.from(this.entries.values());\n        for (const entries of values) {\n            total += entries.reduce((sum, e) => sum + e.amount, 0);\n        }\n        return total;\n    }\n\n    /**\n     * Clear old entries (keep last N days)\n     */\n    cleanup(keepDays = 30): void {\n        const cutoff = new Date();\n        cutoff.setDate(cutoff.getDate() - keepDays);\n        const cutoffStr = cutoff.toISOString().split('T')[0];\n\n        const dates = Array.from(this.entries.keys());\n        for (const date of dates) {\n            if (date < cutoffStr) {\n                this.entries.delete(date);\n            }\n        }\n    }\n\n    /**\n     * Export all data (for persistence)\n     */\n    export(): Record<string, CostEntry[]> {\n        const exported: Record<string, CostEntry[]> = {};\n        const entries = Array.from(this.entries.entries());\n        for (const [date, entriesArray] of entries) {\n            exported[date] = [...entriesArray];\n        }\n        return exported;\n    }\n\n    /**\n     * Import data (from persistence)\n     */\n    import(data: Record<string, CostEntry[]>): void {\n        this.entries.clear();\n        for (const [date, entries] of Object.entries(data)) {\n            this.entries.set(date, [...entries]);\n        }\n    }\n\n    /**\n     * Reset all tracking data\n     */\n    reset(): void {\n        this.entries.clear();\n    }\n\n    /**\n     * Update daily budget\n     */\n    setDailyBudget(budget: number): void {\n        this.dailyBudget = budget;\n    }\n\n    /**\n     * Get current daily budget\n     */\n    getDailyBudget(): number {\n        return this.dailyBudget;\n    }\n\n    private getToday(): string {\n        return new Date().toISOString().split('T')[0];\n    }\n}\n","/**\n * Escalation State Management\n *\n * Tracks the progression of tasks through the 7-level escalation ladder.\n * Maintains attempt counts, errors, resolution status, and cost tracking.\n */\n\n/**\n * The 7 escalation levels\n * - 0: Static Analysis (lint/tsc) - Free, instant\n * - 1: Complexity Evaluation (Ollama) - Free, routes to 2 or 3\n * - 2: Ollama Fix - Free, simple fixes\n * - 3: Jules Session - Free tier, complex work\n * - 4: Jules + Boosted Context - Free tier, more context\n * - 5: Human Review Queue - Free, awaits approval\n * - 6: Cloud Agent (Cursor) - Expensive, requires approval\n */\nexport type EscalationLevel = 0 | 1 | 2 | 3 | 4 | 5 | 6;\n\n/**\n * State for a single task progressing through escalation levels\n */\nexport interface EscalationState {\n    /** Unique task identifier */\n    taskId: string;\n\n    /** Current escalation level (0-6) */\n    level: EscalationLevel;\n\n    /** Attempt counts per level */\n    attempts: Record<string, number>;\n\n    /** Error messages encountered */\n    errors: string[];\n\n    /** Whether the task has been resolved */\n    resolved: boolean;\n\n    /** Total cost incurred (in cents) */\n    cost: number;\n\n    /** Timestamp when state was created */\n    createdAt: string;\n\n    /** Timestamp of last update */\n    updatedAt: string;\n\n    /** Whether human approval has been granted for cloud agents */\n    approved: boolean;\n}\n\n/**\n * Manager for escalation states across multiple tasks\n */\nexport class EscalationStateManager {\n    private states: Map<string, EscalationState> = new Map();\n\n    /**\n     * Create or get state for a task\n     */\n    getState(taskId: string): EscalationState {\n        if (!this.states.has(taskId)) {\n            const now = new Date().toISOString();\n            this.states.set(taskId, {\n                taskId,\n                level: 0,\n                attempts: {},\n                errors: [],\n                resolved: false,\n                cost: 0,\n                createdAt: now,\n                updatedAt: now,\n                approved: false,\n            });\n        }\n        const state = this.states.get(taskId);\n        if (!state) {\n            throw new Error(`Failed to create state for task ${taskId}`);\n        }\n        return state;\n    }\n\n    /**\n     * Update state for a task\n     */\n    updateState(taskId: string, update: Partial<Omit<EscalationState, 'taskId' | 'createdAt'>>): EscalationState {\n        const state = this.getState(taskId);\n        const updated = {\n            ...state,\n            ...update,\n            updatedAt: new Date().toISOString(),\n        };\n        this.states.set(taskId, updated);\n        return updated;\n    }\n\n    /**\n     * Record an attempt at a level\n     */\n    recordAttempt(taskId: string, level: EscalationLevel): EscalationState {\n        const state = this.getState(taskId);\n        const levelKey = `level${level}`;\n        const attempts = {\n            ...state.attempts,\n            [levelKey]: (state.attempts[levelKey] || 0) + 1,\n        };\n        return this.updateState(taskId, { attempts });\n    }\n\n    /**\n     * Record an error\n     */\n    recordError(taskId: string, error: string): EscalationState {\n        const state = this.getState(taskId);\n        const errors = [...state.errors, error];\n        return this.updateState(taskId, { errors });\n    }\n\n    /**\n     * Escalate to next level\n     */\n    escalate(taskId: string): EscalationState {\n        const state = this.getState(taskId);\n        const newLevel = Math.min(6, state.level + 1) as EscalationLevel;\n        return this.updateState(taskId, { level: newLevel });\n    }\n\n    /**\n     * Mark task as resolved\n     */\n    resolve(taskId: string): EscalationState {\n        return this.updateState(taskId, { resolved: true });\n    }\n\n    /**\n     * Add cost to task\n     */\n    addCost(taskId: string, cost: number): EscalationState {\n        const state = this.getState(taskId);\n        return this.updateState(taskId, { cost: state.cost + cost });\n    }\n\n    /**\n     * Set approval status\n     */\n    setApproval(taskId: string, approved: boolean): EscalationState {\n        return this.updateState(taskId, { approved });\n    }\n\n    /**\n     * Reset state for a task\n     */\n    resetState(taskId: string): void {\n        this.states.delete(taskId);\n    }\n\n    /**\n     * Get all states\n     */\n    getAllStates(): EscalationState[] {\n        return Array.from(this.states.values());\n    }\n\n    /**\n     * Get unresolved states\n     */\n    getUnresolved(): EscalationState[] {\n        return this.getAllStates().filter((s) => !s.resolved);\n    }\n\n    /**\n     * Clear all states\n     */\n    clear(): void {\n        this.states.clear();\n    }\n\n    /**\n     * Get total cost across all tasks\n     */\n    getTotalCost(): number {\n        return this.getAllStates().reduce((sum, s) => sum + s.cost, 0);\n    }\n}\n","/**\n * Escalation Ladder\n *\n * Implements a 7-level escalation strategy that exhausts all free options\n * before resorting to expensive cloud agents.\n *\n * Levels:\n * - 0: Static Analysis (lint/tsc) - Free, instant\n * - 1: Complexity Evaluation (Ollama) - Free, routes to 2 or 3\n * - 2: Ollama Fix - Free, simple fixes\n * - 3: Jules Session - Free tier, complex work\n * - 4: Jules + Boosted Context - Free tier, more context\n * - 5: Human Review Queue - Free, awaits approval\n * - 6: Cloud Agent (Cursor) - Expensive, requires approval\n */\n\nimport type { EscalationConfig } from './config.js';\nimport { createEscalationConfig } from './config.js';\nimport { CostTracker } from './cost-tracker.js';\nimport { type EscalationLevel, type EscalationState, EscalationStateManager } from './state.js';\n\n/**\n * Task to be processed by the escalation ladder\n */\nexport interface Task {\n    /** Unique task identifier */\n    id: string;\n    /** Task description */\n    description: string;\n    /** Code/context for the task */\n    context: string;\n    /** Task metadata (e.g., labels, approvals) */\n    metadata?: Record<string, unknown>;\n}\n\n/**\n * Result from processing a task\n */\nexport interface ProcessResult {\n    /** Whether the task was resolved */\n    success: boolean;\n    /** Final escalation level reached */\n    level: EscalationLevel;\n    /** Result data (agent-specific) */\n    data?: unknown;\n    /** Error message if failed */\n    error?: string;\n    /** Total cost incurred (in cents) */\n    cost: number;\n    /** Number of attempts made */\n    attempts: number;\n    /** Trail of levels attempted */\n    trail: Array<{ level: EscalationLevel; success: boolean; error?: string }>;\n}\n\n/**\n * Handler function for a specific escalation level\n */\nexport type LevelHandler = (\n    task: Task,\n    state: EscalationState\n) => Promise<{\n    success: boolean;\n    data?: unknown;\n    error?: string;\n    escalate: boolean;\n    cost?: number;\n}>;\n\n/**\n * Escalation Ladder - intelligently routes tasks through 7 levels\n */\nexport class EscalationLadder {\n    private config: EscalationConfig;\n    private stateManager: EscalationStateManager;\n    private costTracker: CostTracker;\n    private handlers: Map<EscalationLevel, LevelHandler> = new Map();\n\n    constructor(config?: Partial<EscalationConfig>) {\n        this.config = createEscalationConfig(config);\n        this.stateManager = new EscalationStateManager();\n        this.costTracker = new CostTracker(this.config.costBudgetDaily);\n    }\n\n    /**\n     * Register a handler for a specific level\n     */\n    registerHandler(level: EscalationLevel, handler: LevelHandler): this {\n        this.handlers.set(level, handler);\n        return this;\n    }\n\n    /**\n     * Process a task through the escalation ladder\n     */\n    async process(task: Task): Promise<ProcessResult> {\n        const trail: ProcessResult['trail'] = [];\n        let totalCost = 0;\n\n        // Check for cloud agent approval in metadata\n        if (this.hasCloudAgentApproval(task)) {\n            this.stateManager.setApproval(task.id, true);\n        }\n\n        // Start from current level\n        let state = this.stateManager.getState(task.id);\n        let currentLevel = state.level;\n\n        while (currentLevel <= 6) {\n            // Refresh state to get updated attempts\n            state = this.stateManager.getState(task.id);\n\n            // Check if we should skip this level\n            if (this.shouldSkipLevel(currentLevel, state)) {\n                currentLevel = (currentLevel + 1) as EscalationLevel;\n                this.stateManager.updateState(task.id, { level: currentLevel });\n                continue;\n            }\n\n            // Get handler for this level\n            const handler = this.handlers.get(currentLevel);\n            if (!handler) {\n                // No handler registered, skip to next level\n                trail.push({\n                    level: currentLevel,\n                    success: false,\n                    error: 'No handler registered',\n                });\n                currentLevel = (currentLevel + 1) as EscalationLevel;\n                this.stateManager.updateState(task.id, { level: currentLevel });\n                continue;\n            }\n\n            // Check max attempts for this level\n            if (this.hasExceededAttempts(currentLevel, state)) {\n                trail.push({\n                    level: currentLevel,\n                    success: false,\n                    error: 'Max attempts exceeded',\n                });\n                currentLevel = (currentLevel + 1) as EscalationLevel;\n                this.stateManager.updateState(task.id, { level: currentLevel });\n                continue;\n            }\n\n            // Record attempt\n            this.stateManager.recordAttempt(task.id, currentLevel);\n            // Refresh state after recording attempt\n            state = this.stateManager.getState(task.id);\n\n            try {\n                // Execute handler\n                const result = await handler(task, state);\n\n                // Track cost if any\n                if (result.cost) {\n                    totalCost += result.cost;\n                    this.stateManager.addCost(task.id, result.cost);\n                    if (currentLevel === 6) {\n                        // Cloud agent cost\n                        this.costTracker.record(task.id, 'cloud-agent', result.cost, `Level ${currentLevel} execution`);\n                    }\n                }\n\n                // Record in trail\n                trail.push({\n                    level: currentLevel,\n                    success: result.success,\n                    error: result.error,\n                });\n\n                // If successful, mark as resolved\n                if (result.success) {\n                    this.stateManager.resolve(task.id);\n                    return {\n                        success: true,\n                        level: currentLevel,\n                        data: result.data,\n                        cost: totalCost,\n                        attempts: trail.length,\n                        trail,\n                    };\n                }\n\n                // Record error\n                if (result.error) {\n                    this.stateManager.recordError(task.id, result.error);\n                }\n\n                // Check if we should escalate\n                // Get fresh state to check attempts\n                state = this.stateManager.getState(task.id);\n                if (result.escalate || this.hasExceededAttempts(currentLevel, state)) {\n                    currentLevel = (currentLevel + 1) as EscalationLevel;\n                    this.stateManager.updateState(task.id, { level: currentLevel });\n                }\n                // If not escalating and not exceeded, we'll retry same level\n            } catch (error) {\n                const errorMsg = error instanceof Error ? error.message : 'Unknown error';\n                this.stateManager.recordError(task.id, errorMsg);\n                trail.push({\n                    level: currentLevel,\n                    success: false,\n                    error: errorMsg,\n                });\n\n                // Escalate on exception\n                currentLevel = (currentLevel + 1) as EscalationLevel;\n                this.stateManager.updateState(task.id, { level: currentLevel });\n            }\n        }\n\n        // All levels exhausted\n        return {\n            success: false,\n            level: 6,\n            error: 'All escalation levels exhausted',\n            cost: totalCost,\n            attempts: trail.length,\n            trail,\n        };\n    }\n\n    /**\n     * Get state for a task\n     */\n    getState(taskId: string): EscalationState {\n        return this.stateManager.getState(taskId);\n    }\n\n    /**\n     * Reset state for a task\n     */\n    resetState(taskId: string): void {\n        this.stateManager.resetState(taskId);\n    }\n\n    /**\n     * Get all states\n     */\n    getAllStates(): EscalationState[] {\n        return this.stateManager.getAllStates();\n    }\n\n    /**\n     * Get cost tracker\n     */\n    getCostTracker(): CostTracker {\n        return this.costTracker;\n    }\n\n    /**\n     * Get configuration\n     */\n    getConfig(): EscalationConfig {\n        return { ...this.config };\n    }\n\n    /**\n     * Update configuration\n     */\n    updateConfig(update: Partial<EscalationConfig>): void {\n        this.config = { ...this.config, ...update };\n        this.costTracker.setDailyBudget(this.config.costBudgetDaily);\n    }\n\n    /**\n     * Check if level should be skipped\n     */\n    private shouldSkipLevel(level: EscalationLevel, state: EscalationState): boolean {\n        // Level 5 (Human Review) - skip if already approved or approval not required\n        if (level === 5) {\n            return state.approved || !this.config.cloudAgentApprovalRequired;\n        }\n\n        // Level 6 (Cloud Agent) - check if enabled and budget available\n        if (level === 6) {\n            if (!this.config.cloudAgentEnabled) return true;\n            if (this.config.cloudAgentApprovalRequired && !state.approved) return true;\n\n            // Check budget (estimate cloud agent cost at 1000 cents = $10)\n            const estimatedCost = 1000;\n            if (!this.costTracker.canAfford(estimatedCost)) return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Check if level has exceeded max attempts\n     */\n    private hasExceededAttempts(level: EscalationLevel, state: EscalationState): boolean {\n        const levelKey = `level${level}`;\n        const attempts = state.attempts[levelKey] || 0;\n\n        switch (level) {\n            case 2: // Ollama Fix\n                return attempts >= this.config.maxOllamaAttempts;\n            case 3: // Jules Session\n                return attempts >= this.config.maxJulesAttempts;\n            case 4: // Jules + Boosted Context\n                return attempts >= this.config.maxJulesBoostAttempts;\n            default:\n                // Other levels: 1 attempt only\n                return attempts >= 1;\n        }\n    }\n\n    /**\n     * Check if task has cloud agent approval\n     */\n    private hasCloudAgentApproval(task: Task): boolean {\n        if (!task.metadata) return false;\n\n        // Check for 'approved:cloud-agent' in labels\n        const labels = task.metadata.labels as string[] | undefined;\n        if (labels?.includes('approved:cloud-agent')) return true;\n\n        // Check for explicit approval flag\n        const approved = task.metadata.approved as boolean | string[] | undefined;\n        if (typeof approved === 'boolean') return approved;\n        if (Array.isArray(approved)) return approved.includes('cloud-agent');\n\n        return false;\n    }\n}\n","/**\n * Lock Manager Utilities\n *\n * Higher-level utilities for managing distributed locks.\n */\n\nimport type { QueueStorage } from '../storage/interface.js';\nimport type { QueueItem } from './types.js';\n\n/**\n * Lock manager for distributed coordination\n */\nexport class LockManager<T extends QueueItem = QueueItem> {\n    constructor(\n        private storage: QueueStorage<T>,\n        private defaultTimeout = 5 * 60 * 1000 // 5 minutes\n    ) {}\n\n    /**\n     * Execute a function with a lock\n     * Automatically acquires and releases the lock\n     */\n    async withLock<R>(holder: string, fn: () => Promise<R>, timeout?: number): Promise<R> {\n        const acquired = await this.storage.acquireLock(holder, timeout || this.defaultTimeout);\n        if (!acquired) {\n            throw new Error('Failed to acquire lock');\n        }\n\n        try {\n            return await fn();\n        } finally {\n            await this.storage.releaseLock(holder);\n        }\n    }\n\n    /**\n     * Try to execute a function with a lock\n     * Returns null if lock cannot be acquired\n     */\n    async tryWithLock<R>(holder: string, fn: () => Promise<R>, timeout?: number): Promise<R | null> {\n        const acquired = await this.storage.acquireLock(holder, timeout || this.defaultTimeout);\n        if (!acquired) {\n            return null;\n        }\n\n        try {\n            return await fn();\n        } finally {\n            await this.storage.releaseLock(holder);\n        }\n    }\n\n    /**\n     * Check if currently locked\n     */\n    async isLocked(): Promise<boolean> {\n        return this.storage.isLocked();\n    }\n\n    /**\n     * Get current lock holder\n     */\n    async getLockHolder(): Promise<string | null> {\n        const lock = await this.storage.getLock();\n        return lock?.holder || null;\n    }\n\n    /**\n     * Wait for lock to be released\n     * Returns true if lock was released, false if timeout\n     */\n    async waitForRelease(maxWaitMs = 30000, checkIntervalMs = 1000): Promise<boolean> {\n        const startTime = Date.now();\n\n        while (Date.now() - startTime < maxWaitMs) {\n            if (!(await this.isLocked())) {\n                return true;\n            }\n            await new Promise((resolve) => setTimeout(resolve, checkIntervalMs));\n        }\n\n        return false;\n    }\n}\n","/**\n * Queue Manager\n *\n * Core queue management logic that works with any storage backend.\n * Handles priority ordering, locking, and state management.\n */\n\nimport type { QueueStorage } from './storage.js';\nimport type { QueueItem, QueueItemStatus, QueueState, QueueStats } from './types.js';\n\n/**\n * Configuration for the queue manager\n */\nexport interface QueueManagerConfig {\n    /** Lock timeout in milliseconds (default: 5 minutes) */\n    lockTimeout?: number;\n    /** Maximum retries before marking as failed (default: 3) */\n    maxRetries?: number;\n    /** Unique identifier for this manager instance */\n    instanceId?: string;\n}\n\n/**\n * Queue Manager - handles all queue operations\n */\nexport class QueueManager<T extends QueueItem = QueueItem> {\n    private config: Required<QueueManagerConfig>;\n\n    constructor(\n        private storage: QueueStorage<T>,\n        config: QueueManagerConfig = {}\n    ) {\n        this.config = {\n            lockTimeout: config.lockTimeout ?? 5 * 60 * 1000,\n            maxRetries: config.maxRetries ?? 3,\n            instanceId: config.instanceId ?? `manager-${Date.now()}`,\n        };\n    }\n\n    /**\n     * Add an item to the queue\n     */\n    async add(\n        item: Omit<T, 'status' | 'addedAt' | 'retries'> & Partial<Pick<T, 'status' | 'addedAt' | 'retries'>>\n    ): Promise<T> {\n        const state = await this.storage.read();\n\n        // Check for duplicates\n        if (state.items.some((i) => i.id === item.id)) {\n            throw new Error(`Item ${item.id} already in queue`);\n        }\n\n        const newItem = {\n            ...item,\n            status: item.status ?? 'pending',\n            addedAt: item.addedAt ?? new Date().toISOString(),\n            retries: item.retries ?? 0,\n        } as T;\n\n        state.items.push(newItem);\n        this.sortQueue(state.items);\n        this.updateStats(state);\n\n        await this.storage.write(state);\n        return newItem;\n    }\n\n    /**\n     * Remove an item from the queue\n     */\n    async remove(id: string): Promise<T | undefined> {\n        const state = await this.storage.read();\n        const index = state.items.findIndex((i) => i.id === id);\n\n        if (index === -1) return undefined;\n\n        const [removed] = state.items.splice(index, 1);\n        this.updateStats(state);\n        await this.storage.write(state);\n\n        return removed;\n    }\n\n    /**\n     * Get the next item to process (highest priority, oldest first)\n     */\n    async next(): Promise<T | undefined> {\n        const state = await this.storage.read();\n        return state.items.find((i) => i.status === 'pending');\n    }\n\n    /**\n     * Get an item by ID\n     */\n    async get(id: string): Promise<T | undefined> {\n        const state = await this.storage.read();\n        return state.items.find((i) => i.id === id);\n    }\n\n    /**\n     * Update an item's properties\n     */\n    async update(id: string, updates: Partial<Omit<T, 'id'>>): Promise<T | undefined> {\n        const state = await this.storage.read();\n        const item = state.items.find((i) => i.id === id);\n\n        if (!item) return undefined;\n\n        Object.assign(item, updates);\n        this.sortQueue(state.items);\n        this.updateStats(state);\n        await this.storage.write(state);\n\n        return item;\n    }\n\n    /**\n     * Mark an item as processing\n     */\n    async startProcessing(id: string): Promise<T | undefined> {\n        return this.update(id, {\n            status: 'processing',\n            startedAt: new Date().toISOString(),\n        } as Partial<T>);\n    }\n\n    /**\n     * Mark an item as completed and remove from queue\n     */\n    async complete(id: string): Promise<T | undefined> {\n        const item = await this.get(id);\n        if (!item) return undefined;\n\n        const state = await this.storage.read();\n        state.items = state.items.filter((i) => i.id !== id);\n        state.stats.completed24h++;\n        this.updateStats(state);\n        await this.storage.write(state);\n\n        return {\n            ...item,\n            status: 'completed' as QueueItemStatus,\n            completedAt: new Date().toISOString(),\n        };\n    }\n\n    /**\n     * Mark an item as failed\n     * If under max retries, requeue as pending\n     */\n    async fail(id: string, error: string): Promise<T | undefined> {\n        const state = await this.storage.read();\n        const item = state.items.find((i) => i.id === id);\n\n        if (!item) return undefined;\n\n        item.retries++;\n        item.lastError = error;\n\n        if (item.retries >= this.config.maxRetries) {\n            item.status = 'failed';\n            state.stats.failed24h++;\n        } else {\n            item.status = 'pending';\n            item.startedAt = undefined;\n        }\n\n        this.sortQueue(state.items);\n        this.updateStats(state);\n        await this.storage.write(state);\n\n        return item;\n    }\n\n    /**\n     * Cancel an item\n     */\n    async cancel(id: string): Promise<T | undefined> {\n        return this.update(id, { status: 'cancelled' } as Partial<T>);\n    }\n\n    /**\n     * List all items (optionally filtered by status)\n     */\n    async list(status?: QueueItemStatus): Promise<T[]> {\n        const state = await this.storage.read();\n        if (status) {\n            return state.items.filter((i) => i.status === status);\n        }\n        return [...state.items];\n    }\n\n    /**\n     * Get queue statistics\n     */\n    async stats(): Promise<QueueStats> {\n        const state = await this.storage.read();\n        return { ...state.stats };\n    }\n\n    /**\n     * Get current queue length\n     */\n    async length(): Promise<number> {\n        const state = await this.storage.read();\n        return state.items.length;\n    }\n\n    /**\n     * Clear all items (dangerous!)\n     */\n    async clear(): Promise<void> {\n        const state = await this.storage.read();\n        state.items = [];\n        this.updateStats(state);\n        await this.storage.write(state);\n    }\n\n    /**\n     * Acquire a lock for processing\n     */\n    async lock(): Promise<boolean> {\n        return this.storage.acquireLock(this.config.instanceId, this.config.lockTimeout);\n    }\n\n    /**\n     * Release the lock\n     */\n    async unlock(): Promise<void> {\n        return this.storage.releaseLock(this.config.instanceId);\n    }\n\n    /**\n     * Check if queue is locked\n     */\n    async isLocked(): Promise<boolean> {\n        return this.storage.isLocked();\n    }\n\n    /**\n     * Process the next item with a handler\n     * Automatically handles locking, status updates, and error handling\n     */\n    async processNext<R>(handler: (item: T) => Promise<R>): Promise<{ item: T; result: R } | null> {\n        // Try to acquire lock\n        if (!(await this.lock())) {\n            return null;\n        }\n\n        try {\n            const item = await this.next();\n            if (!item) {\n                return null;\n            }\n\n            await this.startProcessing(item.id);\n\n            try {\n                const result = await handler(item);\n                await this.complete(item.id);\n                return { item, result };\n            } catch (error) {\n                await this.fail(item.id, error instanceof Error ? error.message : String(error));\n                throw error;\n            }\n        } finally {\n            await this.unlock();\n        }\n    }\n\n    // ============================================================================\n    // Private Helpers\n    // ============================================================================\n\n    /**\n     * Sort queue by priority (ascending) then by addedAt (ascending)\n     */\n    private sortQueue(items: T[]): void {\n        items.sort((a, b) => {\n            // Pending items first\n            if (a.status !== b.status) {\n                if (a.status === 'pending') return -1;\n                if (b.status === 'pending') return 1;\n            }\n            // Then by priority (lower = higher priority)\n            if (a.priority !== b.priority) {\n                return a.priority - b.priority;\n            }\n            // Then by added time (older first)\n            return new Date(a.addedAt).getTime() - new Date(b.addedAt).getTime();\n        });\n    }\n\n    /**\n     * Update queue statistics\n     */\n    private updateStats(state: QueueState<T>): void {\n        const byStatus: Record<QueueItemStatus, number> = {\n            pending: 0,\n            processing: 0,\n            completed: 0,\n            failed: 0,\n            cancelled: 0,\n        };\n\n        for (const item of state.items) {\n            byStatus[item.status]++;\n        }\n\n        state.stats.total = state.items.length;\n        state.stats.byStatus = byStatus;\n    }\n}\n","/**\n * Priority Scorer\n *\n * Calculates priority scores for PRs based on labels and metadata.\n */\n\nimport type { Priority } from './types.js';\n\nexport interface PRMetadata {\n    labels?: string[];\n    type?: 'ci-fix' | 'security' | 'feature' | 'docs' | 'bugfix' | 'chore';\n    isDraft?: boolean;\n    hasConflicts?: boolean;\n    age?: number; // days old\n    reviewCount?: number;\n}\n\n/** Threshold for age-based priority boost (days) */\nconst AGE_BOOST_THRESHOLD_DAYS = 7;\n\n/** Threshold for review count boost */\nconst REVIEW_COUNT_BOOST_THRESHOLD = 2;\n\n/**\n * Priority scorer for queue items\n */\nexport class PriorityScorer {\n    /**\n     * Calculate priority score from PR metadata\n     * Returns 1 (critical), 2 (normal), or 3 (low)\n     */\n    score(pr: PRMetadata): Priority {\n        let score = 2; // Start with normal priority\n\n        // Type-based scoring\n        if (pr.type) {\n            const typeScore = PriorityScorer.fromType(pr.type);\n            score = Math.min(score, typeScore);\n        }\n\n        // Label-based scoring\n        if (pr.labels && pr.labels.length > 0) {\n            const labelScore = PriorityScorer.fromLabels(pr.labels);\n            score = Math.min(score, labelScore);\n        }\n\n        // Draft PRs are lower priority\n        if (pr.isDraft) {\n            score = Math.max(score, 3);\n        }\n\n        // PRs with conflicts are lower priority\n        if (pr.hasConflicts) {\n            score = Math.max(score, 3);\n        }\n\n        // Age-based boost (old PRs get higher priority)\n        if (pr.age !== undefined && pr.age > AGE_BOOST_THRESHOLD_DAYS) {\n            score = Math.max(1, score - 1) as Priority;\n        }\n\n        // Review count boost\n        if (pr.reviewCount !== undefined && pr.reviewCount > REVIEW_COUNT_BOOST_THRESHOLD) {\n            score = Math.max(1, score - 1) as Priority;\n        }\n\n        return score as Priority;\n    }\n\n    /**\n     * Calculate priority from labels\n     * Looks for priority/critical, priority/high, priority/low labels\n     */\n    static fromLabels(labels: string[]): Priority {\n        const lowerLabels = labels.map((l) => l.toLowerCase());\n\n        // Critical priority indicators\n        if (\n            lowerLabels.some(\n                (l) =>\n                    l.includes('critical') ||\n                    l.includes('urgent') ||\n                    l.includes('hotfix') ||\n                    l === 'priority/critical' ||\n                    l === 'priority: critical' ||\n                    l === 'p0'\n            )\n        ) {\n            return 1;\n        }\n\n        // High priority indicators\n        if (\n            lowerLabels.some(\n                (l) =>\n                    l.includes('high') ||\n                    l.includes('important') ||\n                    l === 'priority/high' ||\n                    l === 'priority: high' ||\n                    l === 'p1'\n            )\n        ) {\n            return 2;\n        }\n\n        // Low priority indicators\n        if (\n            lowerLabels.some(\n                (l) =>\n                    l.includes('low') ||\n                    l.includes('nice-to-have') ||\n                    l === 'priority/low' ||\n                    l === 'priority: low' ||\n                    l === 'p3'\n            )\n        ) {\n            return 3;\n        }\n\n        // Security labels are critical\n        if (lowerLabels.some((l) => l.includes('security') || l.includes('vulnerability'))) {\n            return 1;\n        }\n\n        // Bug/fix labels are high priority\n        if (lowerLabels.some((l) => l.includes('bug') || l.includes('fix'))) {\n            return 2;\n        }\n\n        // Default to normal\n        return 2;\n    }\n\n    /**\n     * Calculate priority from PR type\n     */\n    static fromType(type: 'ci-fix' | 'security' | 'feature' | 'docs' | 'bugfix' | 'chore'): Priority {\n        switch (type) {\n            case 'security':\n            case 'ci-fix':\n                return 1; // Critical\n            case 'bugfix':\n            case 'feature':\n                return 2; // Normal\n            case 'docs':\n            case 'chore':\n                return 3; // Low\n            default:\n                return 2; // Normal\n        }\n    }\n}\n","/**\n * Strata Test Results Format\n *\n * Custom test result format designed for AI-powered triage and diagnosis.\n * Used by both Vitest and Playwright reporters.\n */\n\nexport interface TestResult {\n    /** Unique test identifier */\n    id: string;\n    /** Test name/title */\n    name: string;\n    /** Full test path (describe blocks) */\n    fullName: string;\n    /** Source file containing the test */\n    file: string;\n    /** Line number in source file */\n    line?: number;\n    /** Test status */\n    status: 'passed' | 'failed' | 'skipped' | 'todo';\n    /** Duration in milliseconds */\n    duration: number;\n    /** Error details if failed */\n    error?: TestError;\n    /** Retry attempt number */\n    retry?: number;\n    /** Tags/annotations */\n    tags?: string[];\n}\n\nexport interface TestError {\n    /** Error message */\n    message: string;\n    /** Stack trace */\n    stack?: string;\n    /** Expected value (for assertion errors) */\n    expected?: unknown;\n    /** Actual value (for assertion errors) */\n    actual?: unknown;\n    /** Diff between expected and actual */\n    diff?: string;\n    /** Code snippet around the failure */\n    codeFrame?: string;\n}\n\nexport interface TestFile {\n    /** File path */\n    path: string;\n    /** Tests in this file */\n    tests: TestResult[];\n    /** Setup/teardown errors */\n    setupError?: TestError;\n    /** File-level duration */\n    duration: number;\n}\n\nexport interface CoverageData {\n    /** Total lines */\n    lines: { total: number; covered: number; percentage: number };\n    /** Total functions */\n    functions: { total: number; covered: number; percentage: number };\n    /** Total branches */\n    branches: { total: number; covered: number; percentage: number };\n    /** Total statements */\n    statements: { total: number; covered: number; percentage: number };\n    /** Per-file coverage */\n    files: FileCoverage[];\n}\n\nexport interface FileCoverage {\n    /** File path */\n    path: string;\n    /** Line coverage */\n    lines: { total: number; covered: number; percentage: number };\n    /** Uncovered line numbers */\n    uncoveredLines: number[];\n    /** Function coverage */\n    functions: { total: number; covered: number; percentage: number };\n    /** Uncovered function names */\n    uncoveredFunctions: string[];\n}\n\nexport interface TestReport {\n    /** Report format version */\n    version: '1.0';\n    /** Report generation timestamp */\n    timestamp: string;\n    /** Test runner (vitest, playwright, etc.) */\n    runner: string;\n    /** Test type */\n    type: 'unit' | 'integration' | 'e2e';\n    /** Summary statistics */\n    summary: {\n        total: number;\n        passed: number;\n        failed: number;\n        skipped: number;\n        duration: number;\n    };\n    /** Test files */\n    files: TestFile[];\n    /** Coverage data (if available) */\n    coverage?: CoverageData;\n    /** Git context */\n    git?: {\n        branch: string;\n        commit: string;\n        author?: string;\n        message?: string;\n    };\n    /** CI context */\n    ci?: {\n        provider: string;\n        runId: string;\n        runUrl?: string;\n        prNumber?: number;\n        issueNumbers?: number[];\n    };\n}\n\n/**\n * Parse test report from JSON file\n */\nexport function parseTestReport(json: string): TestReport {\n    const data = JSON.parse(json);\n    if (data.version !== '1.0') {\n        throw new Error(`Unsupported report version: ${data.version}`);\n    }\n    return data as TestReport;\n}\n\n/**\n * Get failed tests from report\n */\nexport function getFailedTests(report: TestReport): TestResult[] {\n    return report.files.flatMap((f) => f.tests.filter((t) => t.status === 'failed'));\n}\n\n/**\n * Get tests by file\n */\nexport function getTestsByFile(report: TestReport, filePath: string): TestResult[] {\n    const file = report.files.find((f) => f.path === filePath || f.path.endsWith(filePath));\n    return file?.tests ?? [];\n}\n\n/**\n * Get low coverage files\n */\nexport function getLowCoverageFiles(report: TestReport, threshold = 80): FileCoverage[] {\n    if (!report.coverage) return [];\n    return report.coverage.files.filter((f) => f.lines.percentage < threshold);\n}\n\n/**\n * Get uncovered functions\n */\nexport function getUncoveredFunctions(report: TestReport): { file: string; functions: string[] }[] {\n    if (!report.coverage) return [];\n    return report.coverage.files\n        .filter((f) => f.uncoveredFunctions.length > 0)\n        .map((f) => ({ file: f.path, functions: f.uncoveredFunctions }));\n}\n\n/**\n * Format test results for AI analysis\n */\nexport function formatForAI(report: TestReport): string {\n    const lines: string[] = [];\n\n    lines.push(`# Test Report (${report.runner} - ${report.type})`);\n    lines.push(`Generated: ${report.timestamp}`);\n    lines.push('');\n\n    // Summary\n    lines.push('## Summary');\n    lines.push(`- Total: ${report.summary.total}`);\n    lines.push(`- Passed: ${report.summary.passed} ‚úÖ`);\n    lines.push(`- Failed: ${report.summary.failed} ‚ùå`);\n    lines.push(`- Skipped: ${report.summary.skipped} ‚è≠Ô∏è`);\n    lines.push(`- Duration: ${(report.summary.duration / 1000).toFixed(2)}s`);\n    lines.push('');\n\n    // Git context\n    if (report.git) {\n        formatGitContext(lines, report.git);\n    }\n\n    // Failed tests\n    const failed = getFailedTests(report);\n    if (failed.length > 0) {\n        formatFailedTests(lines, failed);\n    }\n\n    // Coverage\n    if (report.coverage) {\n        formatCoverage(lines, report);\n    }\n\n    return lines.join('\\n');\n}\n\nfunction formatGitContext(lines: string[], git: NonNullable<TestReport['git']>): void {\n    lines.push('## Git Context');\n    lines.push(`- Branch: ${git.branch}`);\n    lines.push(`- Commit: ${git.commit}`);\n    if (git.message) lines.push(`- Message: ${git.message}`);\n    lines.push('');\n}\n\nfunction formatFailedTests(lines: string[], failed: TestResult[]): void {\n    lines.push('## Failed Tests');\n    for (const test of failed) {\n        lines.push(`### ${test.fullName}`);\n        lines.push(`- File: ${test.file}${test.line ? `:${test.line}` : ''}`);\n        lines.push(`- Duration: ${test.duration}ms`);\n        if (test.error) {\n            formatTestError(lines, test.error);\n        }\n        lines.push('');\n    }\n}\n\nfunction formatTestError(lines: string[], error: TestError): void {\n    lines.push('');\n    lines.push('**Error:**');\n    lines.push('```');\n    lines.push(error.message);\n    if (error.codeFrame) {\n        lines.push('');\n        lines.push(error.codeFrame);\n    }\n    lines.push('```');\n    if (error.diff) {\n        lines.push('');\n        lines.push('**Diff:**');\n        lines.push('```diff');\n        lines.push(error.diff);\n        lines.push('```');\n    }\n}\n\nfunction formatCoverage(lines: string[], report: TestReport): void {\n    const coverage = report.coverage;\n    if (!coverage) return;\n    lines.push('## Coverage');\n    lines.push(`- Lines: ${coverage.lines.percentage.toFixed(1)}%`);\n    lines.push(`- Functions: ${coverage.functions.percentage.toFixed(1)}%`);\n    lines.push(`- Branches: ${coverage.branches.percentage.toFixed(1)}%`);\n    lines.push('');\n\n    const lowCoverage = getLowCoverageFiles(report, 80);\n    if (lowCoverage.length > 0) {\n        lines.push('### Low Coverage Files (<80%)');\n        for (const file of lowCoverage.slice(0, 10)) {\n            lines.push(`- ${file.path}: ${file.lines.percentage.toFixed(1)}%`);\n        }\n        lines.push('');\n    }\n}\n","/**\n * Playwright MCP Client\n *\n * Connects to @playwright/mcp for browser automation and E2E test generation.\n * Used for:\n * - Running E2E tests\n * - Generating test code from user flows\n * - Verifying changes in the browser\n */\n\nimport { experimental_createMCPClient as createMCPClient } from '@ai-sdk/mcp';\nimport { Experimental_StdioMCPTransport as StdioMCPTransport } from '@ai-sdk/mcp/mcp-stdio';\n\nexport type MCPClient = Awaited<ReturnType<typeof createMCPClient>>;\n\nexport interface PlaywrightOptions {\n    headless?: boolean;\n    browser?: 'chromium' | 'firefox' | 'webkit';\n    viewport?: { width: number; height: number };\n    outputDir?: string;\n    saveTrace?: boolean;\n    testingCapabilities?: boolean;\n}\n\n/**\n * Create a Playwright MCP client\n */\nexport async function createPlaywrightClient(options: PlaywrightOptions = {}): Promise<MCPClient> {\n    const {\n        headless = true,\n        browser = 'chromium',\n        outputDir = './test-output',\n        saveTrace = false,\n        testingCapabilities = true,\n    } = options;\n\n    const args = ['@playwright/mcp@latest'];\n\n    if (headless) args.push('--headless');\n    args.push('--browser', browser);\n    args.push('--output-dir', outputDir);\n\n    if (saveTrace) args.push('--save-trace');\n    if (testingCapabilities) args.push('--caps=testing');\n\n    const transport = new StdioMCPTransport({\n        command: 'npx',\n        args,\n    });\n\n    const client = await createMCPClient({\n        transport,\n    });\n\n    return client;\n}\n\n/**\n * Get Playwright tools from the MCP client\n */\nexport async function getPlaywrightTools(client: MCPClient): Promise<Awaited<ReturnType<MCPClient['tools']>>> {\n    return client.tools();\n}\n\n/**\n * Available Playwright MCP tools (for reference)\n */\nexport const PLAYWRIGHT_TOOLS = {\n    // Core automation\n    NAVIGATE: 'browser_navigate',\n    CLICK: 'browser_click',\n    TYPE: 'browser_type',\n    SNAPSHOT: 'browser_snapshot',\n    SCREENSHOT: 'browser_take_screenshot',\n    CLOSE: 'browser_close',\n    WAIT: 'browser_wait_for',\n    EVALUATE: 'browser_evaluate',\n\n    // Testing assertions (requires --caps=testing)\n    VERIFY_ELEMENT_VISIBLE: 'browser_verify_element_visible',\n    VERIFY_TEXT_VISIBLE: 'browser_verify_text_visible',\n    VERIFY_VALUE: 'browser_verify_value',\n    GENERATE_LOCATOR: 'browser_generate_locator',\n} as const;\n"],"mappings":"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","names":["lock","client","data"]}