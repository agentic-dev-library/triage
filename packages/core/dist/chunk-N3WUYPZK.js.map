{"version":3,"sources":["../src/triage/connectors.ts","../src/handlers/connectors.ts","../src/handlers/issue.ts","../src/handlers/pr.ts","../src/handlers/review.ts","../src/handlers/sage.ts"],"sourcesContent":["/**\n * TriageConnectors - Unified API for Issue/Project/Review Management\n *\n * Following the vendor-connectors pattern from the jbcom ecosystem,\n * this class provides cached access to all triage connectors with:\n *\n * 1. Direct TypeScript API - Use connectors directly in your code\n * 2. Vercel AI SDK Tools - Standard tools for AI agents (see tools.ts)\n *\n * Similar to how VendorConnectors provides `get_*_client()` getters,\n * TriageConnectors provides namespaced APIs for issues, projects, and reviews.\n *\n * @example\n * ```typescript\n * import { TriageConnectors } from '@strata/triage';\n *\n * // Initialize once - reads credentials from environment\n * const triage = new TriageConnectors();\n *\n * // Issue operations\n * const issues = await triage.issues.list({ status: 'open' });\n * const issue = await triage.issues.create({ title: 'Fix bug', type: 'bug' });\n * await triage.issues.update('123', { priority: 'high' });\n * await triage.issues.close('123', 'Fixed in PR #456');\n *\n * // Get ready work (no blockers)\n * const ready = await triage.issues.getReadyWork({ limit: 5 });\n *\n * // Statistics\n * const stats = await triage.issues.getStats();\n * ```\n */\n\nimport { createBestProvider, createProvider, type ProviderConfig } from '@agentic/triage-trackers';\nimport type {\n    CreateIssueOptions,\n    ListIssuesOptions,\n    ProviderStats,\n    ReadyWork,\n    TriageIssue,\n    TriageProvider,\n    UpdateIssueOptions,\n} from '@agentic/triage-trackers';\n\n// =============================================================================\n// Configuration\n// =============================================================================\n\nexport interface TriageConnectorsConfig {\n    /**\n     * Provider configuration. If not provided, will auto-detect.\n     * Can be a single config or multiple for different providers.\n     */\n    provider?: ProviderConfig;\n\n    /**\n     * Working directory for local providers (Beads)\n     */\n    workingDir?: string;\n\n    /**\n     * Repository for GitHub provider (owner/repo format)\n     */\n    repo?: string;\n\n    /**\n     * Prefer Beads over GitHub when both are available\n     * @default true\n     */\n    preferBeads?: boolean;\n}\n\n// =============================================================================\n// TriageConnectors Class\n// =============================================================================\n\n/**\n * Unified triage connector providing issue, project, and review APIs.\n *\n * This is the main entry point for programmatic triage operations.\n * For AI agent tools, see `getTriageTools()` in tools.ts.\n */\nexport class TriageConnectors {\n    private config: TriageConnectorsConfig;\n    private _provider: TriageProvider | null = null;\n    private _initPromise: Promise<void> | null = null;\n\n    /**\n     * Issue operations API\n     */\n    public readonly issues: IssueAPI;\n\n    /**\n     * Project operations API (boards, sprints, epics)\n     * @remarks Coming soon - currently returns stubs\n     */\n    public readonly projects: ProjectAPI;\n\n    /**\n     * Review operations API (PR feedback, comments)\n     * @remarks Coming soon - currently returns stubs\n     */\n    public readonly reviews: ReviewAPI;\n\n    constructor(config: TriageConnectorsConfig = {}) {\n        this.config = config;\n\n        // Initialize namespaced APIs\n        this.issues = new IssueAPI(this);\n        this.projects = new ProjectAPI();\n        this.reviews = new ReviewAPI();\n    }\n\n    /**\n     * Get or initialize the underlying provider\n     */\n    async getProvider(): Promise<TriageProvider> {\n        if (this._provider) {\n            return this._provider;\n        }\n\n        // Use promise-based locking to prevent concurrent initialization\n        if (this._initPromise) {\n            await this._initPromise;\n            if (!this._provider) {\n                throw new Error('Provider initialization failed');\n            }\n            return this._provider;\n        }\n\n        this._initPromise = this.initializeProvider();\n        await this._initPromise;\n        if (!this._provider) {\n            throw new Error('Provider initialization failed');\n        }\n        return this._provider;\n    }\n\n    /**\n     * Reconfigure the connectors with a new configuration.\n     * This will reset the underlying provider.\n     */\n    async reconfigure(config: TriageConnectorsConfig): Promise<void> {\n        this.config = config;\n        this._provider = null;\n        this._initPromise = null;\n        await this.getProvider();\n    }\n\n    private async initializeProvider(): Promise<void> {\n        if (this.config.provider) {\n            this._provider = createProvider(this.config.provider);\n        } else {\n            this._provider = await createBestProvider({\n                workingDir: this.config.workingDir,\n                repo: this.config.repo,\n                preferBeads: this.config.preferBeads,\n            });\n        }\n    }\n\n    /**\n     * Get the provider name\n     */\n    async getProviderName(): Promise<string> {\n        const provider = await this.getProvider();\n        return provider.name;\n    }\n\n    /**\n     * Check if the connector is ready\n     */\n    async isReady(): Promise<boolean> {\n        try {\n            const provider = await this.getProvider();\n            return provider.isReady();\n        } catch {\n            return false;\n        }\n    }\n\n    /**\n     * Sync with remote (for providers that support it)\n     */\n    async sync(): Promise<void> {\n        const provider = await this.getProvider();\n        if (provider.sync) {\n            await provider.sync();\n        }\n    }\n}\n\n// =============================================================================\n// Issue API\n// =============================================================================\n\n/**\n * Issue operations API - CRUD and query operations for issues\n */\nclass IssueAPI {\n    constructor(private connectors: TriageConnectors) {}\n\n    /**\n     * Create a new issue\n     */\n    async create(options: CreateIssueOptions): Promise<TriageIssue> {\n        const provider = await this.connectors.getProvider();\n        return provider.createIssue(options);\n    }\n\n    /**\n     * Get an issue by ID\n     */\n    async get(id: string): Promise<TriageIssue | null> {\n        const provider = await this.connectors.getProvider();\n        return provider.getIssue(id);\n    }\n\n    /**\n     * Update an existing issue\n     */\n    async update(id: string, options: UpdateIssueOptions): Promise<TriageIssue> {\n        const provider = await this.connectors.getProvider();\n        return provider.updateIssue(id, options);\n    }\n\n    /**\n     * Close an issue\n     */\n    async close(id: string, reason?: string): Promise<TriageIssue> {\n        const provider = await this.connectors.getProvider();\n        return provider.closeIssue(id, reason);\n    }\n\n    /**\n     * Reopen an issue\n     */\n    async reopen(id: string, reason?: string): Promise<TriageIssue> {\n        const provider = await this.connectors.getProvider();\n        return provider.reopenIssue(id, reason);\n    }\n\n    /**\n     * Delete an issue (if supported by provider)\n     */\n    async delete(id: string): Promise<void> {\n        const provider = await this.connectors.getProvider();\n        if (provider.deleteIssue) {\n            await provider.deleteIssue(id);\n        } else {\n            throw new Error(`Delete not supported by ${provider.name} provider`);\n        }\n    }\n\n    /**\n     * List issues with optional filters\n     */\n    async list(options?: ListIssuesOptions): Promise<TriageIssue[]> {\n        const provider = await this.connectors.getProvider();\n        return provider.listIssues(options);\n    }\n\n    /**\n     * Search issues by text query\n     */\n    async search(query: string, options?: ListIssuesOptions): Promise<TriageIssue[]> {\n        const provider = await this.connectors.getProvider();\n        return provider.searchIssues(query, options);\n    }\n\n    /**\n     * Get issues ready to work on (no blockers)\n     */\n    async getReadyWork(options?: { limit?: number }): Promise<ReadyWork[]> {\n        const provider = await this.connectors.getProvider();\n        return provider.getReadyWork(options);\n    }\n\n    /**\n     * Get blocked issues\n     */\n    async getBlocked(): Promise<TriageIssue[]> {\n        const provider = await this.connectors.getProvider();\n        return provider.getBlockedIssues();\n    }\n\n    /**\n     * Add labels to an issue\n     */\n    async addLabels(id: string, labels: string[]): Promise<void> {\n        const provider = await this.connectors.getProvider();\n        await provider.addLabels(id, labels);\n    }\n\n    /**\n     * Remove labels from an issue\n     */\n    async removeLabels(id: string, labels: string[]): Promise<void> {\n        const provider = await this.connectors.getProvider();\n        await provider.removeLabels(id, labels);\n    }\n\n    /**\n     * Get provider statistics\n     */\n    async getStats(): Promise<ProviderStats> {\n        const provider = await this.connectors.getProvider();\n        return provider.getStats();\n    }\n}\n\n// =============================================================================\n// Project API (Coming Soon)\n// =============================================================================\n\n/**\n * Project operations API - boards, sprints, epics\n *\n * @remarks This API is under development. Currently returns stubs.\n */\nclass ProjectAPI {\n    /**\n     * List sprints/iterations\n     */\n    async getSprints(): Promise<{ id: string; name: string; status: string }[]> {\n        // TODO: Implement when project providers are ready\n        return [];\n    }\n\n    /**\n     * Get current sprint\n     */\n    async getCurrentSprint(): Promise<{ id: string; name: string; status: string } | null> {\n        // TODO: Implement when project providers are ready\n        return null;\n    }\n\n    /**\n     * Get epics\n     */\n    async getEpics(): Promise<{ id: string; title: string; progress: number }[]> {\n        // TODO: Implement when project providers are ready\n        return [];\n    }\n}\n\n// =============================================================================\n// Review API (Coming Soon)\n// =============================================================================\n\n/**\n * Review operations API - PR feedback, comments, approvals\n *\n * @remarks This API is under development. Currently returns stubs.\n */\nclass ReviewAPI {\n    /**\n     * Get PR review comments\n     */\n    async getPRComments(_prNumber: number): Promise<\n        {\n            id: string;\n            body: string;\n            author: string;\n            path?: string;\n            line?: number;\n        }[]\n    > {\n        // TODO: Implement using existing octokit.ts functions\n        return [];\n    }\n\n    /**\n     * Get unresolved feedback on a PR\n     */\n    async getUnresolvedFeedback(_prNumber: number): Promise<\n        {\n            id: string;\n            body: string;\n            author: string;\n            type: 'comment' | 'change_request';\n        }[]\n    > {\n        // TODO: Implement\n        return [];\n    }\n\n    /**\n     * Reply to a review comment\n     */\n    async replyToComment(_commentId: string, _body: string): Promise<void> {\n        // TODO: Implement using existing octokit.ts functions\n    }\n}\n\n// =============================================================================\n// Convenience Functions\n// =============================================================================\n\n/**\n * Create a TriageConnectors instance with auto-detection\n *\n * @example\n * ```typescript\n * const triage = await createTriageConnectors();\n * const issues = await triage.issues.list({ status: 'open' });\n * ```\n */\nexport async function createTriageConnectors(config?: TriageConnectorsConfig): Promise<TriageConnectors> {\n    const connectors = new TriageConnectors(config);\n    // Pre-initialize the provider\n    await connectors.getProvider();\n    return connectors;\n}\n","import { TriageConnectors } from '../triage/connectors.js';\n\nlet _connectors: TriageConnectors | null = null;\n\n/**\n * Get the global TriageConnectors instance\n * @param customConnectors Optional custom connectors to use\n * @returns The TriageConnectors instance\n */\nexport function getConnectors(customConnectors?: TriageConnectors): TriageConnectors {\n    if (customConnectors) return customConnectors;\n    if (!_connectors) {\n        _connectors = new TriageConnectors();\n    }\n    return _connectors;\n}\n\n/**\n * Set the global TriageConnectors instance\n * @param connectors The connectors instance to set\n */\nexport function setConnectors(connectors: TriageConnectors | null): void {\n    _connectors = connectors;\n}\n","import { generateObject, type LanguageModel } from 'ai';\nimport type { ListIssuesOptions } from '@agentic/triage-trackers';\nimport { IssueTriageSchema } from '../schemas/index.js';\nimport type { IssueTriage } from '../schemas/issue.js';\nimport type { TriageConnectors } from '../triage/connectors.js';\nimport { getConnectors } from './connectors.js';\n\n/**\n * Handler for triaging an issue\n */\nexport async function handleTriageIssue(id: string, analysis: IssueTriage, customConnectors?: TriageConnectors) {\n    try {\n        const connectors = getConnectors(customConnectors);\n\n        // Update the issue with the analysis\n        await connectors.issues.update(id, {\n            title: analysis.title,\n            priority: analysis.priority,\n            type: analysis.type,\n        });\n\n        // Add labels\n        if (analysis.labels.length > 0) {\n            await connectors.issues.addLabels(id, analysis.labels);\n        }\n\n        return {\n            success: true,\n            message: `Issue ${id} triaged successfully`,\n            analysis,\n        };\n    } catch (error) {\n        return {\n            success: false,\n            message: `Failed to triage issue ${id}: ${error instanceof Error ? error.message : String(error)}`,\n            error,\n        };\n    }\n}\n\n/**\n * Handler for listing issues\n */\nexport async function handleListIssues(filters: ListIssuesOptions, customConnectors?: TriageConnectors) {\n    try {\n        const connectors = getConnectors(customConnectors);\n        return await connectors.issues.list(filters);\n    } catch (error) {\n        console.error('Failed to list issues:', error);\n        throw error;\n    }\n}\n\n/**\n * Handler for getting an issue\n */\nexport async function handleGetIssue(id: string, customConnectors?: TriageConnectors) {\n    try {\n        const connectors = getConnectors(customConnectors);\n        return await connectors.issues.get(id);\n    } catch (error) {\n        console.error(`Failed to get issue ${id}:`, error);\n        throw error;\n    }\n}\n\n/**\n * Analyze an issue using the provided language model.\n *\n * @param issueBody - The content of the issue to analyze\n * @param model - The Vercel AI SDK model to use\n * @returns The structured analysis result\n */\nexport async function analyzeIssue(issueBody: string, model: LanguageModel) {\n    if (!issueBody) {\n        throw new Error('Issue body is required');\n    }\n\n    const result = await generateObject({\n        model,\n        schema: IssueTriageSchema,\n        prompt: `Analyze the following issue and provide a summary, impact, and suggestions:\\n\\n${issueBody}`,\n    });\n\n    return result.object;\n}\n","import type { PRAnalysis } from '../schemas/pr.js';\n\n/**\n * Handler for analyzing a PR\n */\nexport async function handleAnalyzePR(prNumber: number, analysis: PRAnalysis) {\n    try {\n        // Logic to store analysis or update PR labels/comments\n        // This is a placeholder for future implementation\n\n        return {\n            success: true,\n            message: `Analysis for PR #${prNumber} completed`,\n            analysis,\n        };\n    } catch (error) {\n        return {\n            success: false,\n            message: `Failed to analyze PR #${prNumber}: ${error instanceof Error ? error.message : String(error)}`,\n            error,\n        };\n    }\n}\n","import type { CodeReview } from '../schemas/review.js';\n\n/**\n * Handler for submitting a code review\n */\nexport async function handleSubmitReview(prNumber: number, review: CodeReview) {\n    try {\n        // In a real implementation, this would call GitHub API via connectors\n        // For now, we'll use the existing stub or implement it in connectors\n\n        return {\n            success: true,\n            message: `Review for PR #${prNumber} submitted with status: ${review.status}`,\n            review,\n        };\n    } catch (error) {\n        return {\n            success: false,\n            message: `Failed to submit review for PR #${prNumber}: ${error instanceof Error ? error.message : String(error)}`,\n            error,\n        };\n    }\n}\n","import { generateObject, type LanguageModel } from 'ai';\nimport {\n    type AgentRouting,\n    AgentRoutingSchema,\n    type SageQueryType,\n    type SageResponse,\n    SageResponseSchema,\n    type TaskDecomposition,\n    TaskDecompositionSchema,\n    type UnblockResponse,\n    UnblockResponseSchema,\n} from '../schemas/sage.js';\n\nexport type { AgentRouting, SageResponse, TaskDecomposition, UnblockResponse, SageQueryType };\n\n/**\n * Context that can be provided to Sage for better responses\n */\nexport interface SageContext {\n    /** Repository structure (file list) */\n    repoStructure?: string;\n    /** Content from key files (README, CLAUDE.md, etc.) */\n    keyFiles?: Record<string, string>;\n    /** Issue or PR context if available */\n    issueContext?: string;\n    /** Current working directory or file context */\n    currentContext?: string;\n}\n\n/**\n * Classify a query into a SageQueryType\n */\nexport function classifyQuery(query: string): SageQueryType {\n    const lower = query.toLowerCase();\n\n    if (/\\b(review|feedback|look at|check)\\b/.test(lower)) return 'review';\n    if (/\\b(blocked|stuck|help|unblock|can't|cannot)\\b/.test(lower)) return 'unblock';\n    if (/\\b(how|what|why|explain|where|when)\\b/.test(lower)) return 'question';\n    if (/\\b(fix|bug|error|broken|failing|crash)\\b/.test(lower)) return 'fix';\n    if (/\\b(implement|create|add|build|make|write)\\b/.test(lower)) return 'implement';\n    if (/\\b(refactor|cleanup|improve|optimize|reorganize)\\b/.test(lower)) return 'refactor';\n    if (/\\b(decompose|break down|plan|tasks|subtasks|steps)\\b/.test(lower)) return 'decompose';\n    if (/\\b(route|assign|delegate|who should)\\b/.test(lower)) return 'route';\n\n    return 'general';\n}\n\n/**\n * Build the system prompt for Sage\n */\nfunction buildSystemPrompt(context?: SageContext): string {\n    let prompt = `You are the Ecosystem Sage - an intelligent advisor for software development.\n\nYour role:\n1. Answer technical questions accurately and concisely\n2. Provide code review feedback when asked\n3. Decompose complex tasks into actionable subtasks\n4. Help unblock stuck developers and agents\n5. Route work to the appropriate agent (Cursor, Jules, Claude, or Human)\n\nAgent Capabilities:\n- CURSOR: Best for quick fixes (<10 lines), single-file changes, debugging, CI failure resolution\n- JULES: Best for multi-file refactors, documentation, complex feature architecture\n- CLAUDE: Best for complex reasoning, implementation of new features, deep analysis\n- OLLAMA: Best for quick answers, simple query classification, local task execution\n- HUMAN: Required for product decisions, security reviews, architecture approval, human-in-the-loop validation\n\nGuidelines:\n- Be concise and actionable\n- Reference specific files when relevant\n- Never hallucinate - if unsure, say so\n- Provide confidence levels honestly\n- Format responses in Markdown\n- Align with jbcom/control-center ecosystem workflows`;\n\n    if (context?.repoStructure) {\n        prompt += `\\n\\nRepository Structure:\\n${context.repoStructure}`;\n    }\n\n    if (context?.keyFiles) {\n        prompt += '\\n\\nKey Files:';\n        for (const [file, content] of Object.entries(context.keyFiles)) {\n            prompt += `\\n\\n=== ${file} ===\\n${content.slice(0, 2000)}`;\n        }\n    }\n\n    if (context?.issueContext) {\n        prompt += `\\n\\nIssue/PR Context:\\n${context.issueContext}`;\n    }\n\n    if (context?.currentContext) {\n        prompt += `\\n\\nCurrent Context:\\n${context.currentContext}`;\n    }\n\n    return prompt;\n}\n\n/**\n * Answer a question or provide guidance using Sage\n *\n * @param query - The question or request\n * @param model - The Vercel AI SDK model to use\n * @param context - Optional context for better responses\n * @returns Structured Sage response\n */\nexport async function answerQuestion(\n    query: string,\n    model: LanguageModel,\n    context?: SageContext\n): Promise<SageResponse> {\n    if (!query?.trim()) {\n        throw new Error('Query is required');\n    }\n\n    const queryType = classifyQuery(query);\n\n    const result = await generateObject({\n        model,\n        schema: SageResponseSchema,\n        system: buildSystemPrompt(context),\n        prompt: `Query Type: ${queryType}\n\nQuery:\n${query}\n\nProvide a helpful, accurate response. Include file references if relevant.\nIf the query suggests work that should be delegated, include an agent recommendation.`,\n    });\n\n    return result.object;\n}\n\n/**\n * Decompose a complex task into subtasks with agent assignments\n *\n * @param task - The task to decompose\n * @param model - The Vercel AI SDK model to use\n * @param context - Optional context for better decomposition\n * @returns Structured task decomposition\n */\nexport async function decomposeTask(\n    task: string,\n    model: LanguageModel,\n    context?: SageContext\n): Promise<TaskDecomposition> {\n    if (!task?.trim()) {\n        throw new Error('Task is required');\n    }\n\n    const result = await generateObject({\n        model,\n        schema: TaskDecompositionSchema,\n        system: buildSystemPrompt(context),\n        prompt: `Decompose this task into specific, actionable subtasks.\n\nTask:\n${task}\n\nFor each subtask:\n1. Assign a unique ID (task-001, task-002, etc.)\n2. Write a clear, actionable title\n3. Provide detailed description\n4. Assign to the most appropriate agent (cursor/jules/ollama/human)\n5. Set priority (1=highest, 10=lowest)\n6. Estimate effort (small/medium/large)\n7. Note dependencies on other subtasks\n\nOrder subtasks logically for execution.`,\n    });\n\n    return result.object;\n}\n\n/**\n * Determine which agent should handle a task\n *\n * @param task - The task description\n * @param model - The Vercel AI SDK model to use\n * @param context - Optional context for better routing\n * @returns Agent routing decision\n */\nexport async function routeToAgent(task: string, model: LanguageModel, context?: SageContext): Promise<AgentRouting> {\n    if (!task?.trim()) {\n        throw new Error('Task is required');\n    }\n\n    const result = await generateObject({\n        model,\n        schema: AgentRoutingSchema,\n        system: buildSystemPrompt(context),\n        prompt: `Determine which agent should handle this task.\n\nTask:\n${task}\n\nConsider:\n- Task complexity and scope\n- Number of files likely affected\n- Need for human judgment\n- Security implications\n- Time sensitivity\n\nProvide clear reasoning and specific instructions for the chosen agent.`,\n    });\n\n    return result.object;\n}\n\n/**\n * Help unblock stuck work\n *\n * @param situation - Description of the blocked situation\n * @param model - The Vercel AI SDK model to use\n * @param context - Optional context for better diagnosis\n * @returns Unblock suggestions\n */\nexport async function unblock(\n    situation: string,\n    model: LanguageModel,\n    context?: SageContext\n): Promise<UnblockResponse> {\n    if (!situation?.trim()) {\n        throw new Error('Situation description is required');\n    }\n\n    const result = await generateObject({\n        model,\n        schema: UnblockResponseSchema,\n        system: buildSystemPrompt(context),\n        prompt: `Analyze this blocked situation and provide suggestions to unblock.\n\nSituation:\n${situation}\n\nDiagnose the root cause and provide:\n1. Clear diagnosis of what's blocking\n2. Root cause analysis\n3. Ordered list of suggestions (most likely to work first)\n4. The single most important immediate action\n5. Whether human intervention is required`,\n    });\n\n    return result.object;\n}\n\n/**\n * High-level Sage function that auto-routes to the appropriate handler\n *\n * @param query - The question, task, or situation\n * @param model - The Vercel AI SDK model to use\n * @param context - Optional context\n * @returns Response appropriate to the query type\n */\nexport async function sage(\n    query: string,\n    model: LanguageModel,\n    context?: SageContext\n): Promise<SageResponse | TaskDecomposition | AgentRouting | UnblockResponse> {\n    const queryType = classifyQuery(query);\n\n    switch (queryType) {\n        case 'decompose':\n            return decomposeTask(query, model, context);\n        case 'route':\n            return routeToAgent(query, model, context);\n        case 'unblock':\n            return unblock(query, model, context);\n        default:\n            return answerQuestion(query, model, context);\n    }\n}\n"],"mappings":"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","names":["generateObject","generateObject"]}